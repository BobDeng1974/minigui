<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\bin\RTOSDemo.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\bin\RTOSDemo.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, RVCT3.1 [Build 939]: Last Updated: Wed Apr 14 19:45:40 2010
<BR><P>
<H3>Maximum Stack Usage =        184 bytes + Unknown(Functions without stacksize, Cycles, Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
main &rArr; vStartBlockingQueueTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
<P>
<H3>
Functions with no stack information
</H3><UL>
 <LI><a href="#[bc3328]">Reset_Handler</a>
 <LI><a href="#[bc3370]">__user_initial_stackheap</a>
 <LI><a href="#[bbe1e8]">vUART_ISREntry</a>
 <LI><a href="#[bb5db8]">vPortStartFirstTask</a>
 <LI><a href="#[bb8608]">vPortYield</a>
 <LI><a href="#[bc3250]">vPortYieldProcessor</a>
 <LI><a href="#[bb5d70]">vPreemptiveTick</a>
 <LI><a href="#[bc35b0]">Undef_Handler</a>
 <LI><a href="#[bc3568]">PAbt_Handler</a>
 <LI><a href="#[bc3520]">DAbt_Handler</a>
 <LI><a href="#[bc34d8]">IRQ_Handler</a>
 <LI><a href="#[bc3490]">FIQ_Handler</a>
</UL>
</UL>
<P>
<H3>
Mutually Recursive functions
</H3> <LI><a href="#[bc35b0]">Undef_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[bc35b0]">Undef_Handler</a><BR>
 <LI><a href="#[bc3568]">PAbt_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[bc3568]">PAbt_Handler</a><BR>
 <LI><a href="#[bc3520]">DAbt_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[bc3520]">DAbt_Handler</a><BR>
 <LI><a href="#[bc34d8]">IRQ_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[bc34d8]">IRQ_Handler</a><BR>
 <LI><a href="#[bc3490]">FIQ_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[bc3490]">FIQ_Handler</a><BR>
</UL>
<P>
<H3>
Function Pointers
</H3><UL>
 <LI><a href="#[bc3328]">Reset_Handler</a>
 <LI><a href="#[bc35b0]">Undef_Handler</a>
 <LI><a href="#[bc3250]">vPortYieldProcessor</a>
 <LI><a href="#[bc3568]">PAbt_Handler</a>
 <LI><a href="#[bc3520]">DAbt_Handler</a>
 <LI><a href="#[bc34d8]">IRQ_Handler</a>
 <LI><a href="#[bc3490]">FIQ_Handler</a>
 <LI><a href="#[fe54e0]">__main</a>
 <LI><a href="#[11e7b00]">__ARM_get_argv</a>
 <LI><a href="#[bbe1e8]">vUART_ISREntry</a>
 <LI><a href="#[bbe350]">vUART_ISRHandler</a>
 <LI><a href="#[bb5d70]">vPreemptiveTick</a>
 <LI><a href="#[1019a08]">EWindow::~EWindow()</a>
 <LI><a href="#[1019b28]">ELabel::~ELabel()</a>
 <LI><a href="#[1019a98]">EButton::~EButton()</a>
 <LI><a href="#[1019c90]">ECheckButton::~ECheckButton()</a>
 <LI><a href="#[1019bb8]">EEdit::~EEdit()</a>
 <LI><a href="#[100e368]">EG_RedrawFunc_DefaultELabel(EControl*)</a>
 <LI><a href="#[100e320]">EG_RedrawFunc_DefaultEButton(EControl*)</a>
 <LI><a href="#[100e2d8]">EG_CallbackFunc_DefaultECheckButton(EControl*, EEvent*)</a>
 <LI><a href="#[100e290]">EG_RedrawFunc_DefaultECheckButton(EControl*)</a>
 <LI><a href="#[100e200]">EG_RedrawFunc_DefaultEEdit(EControl*)</a>
 <LI><a href="#[100e248]">EG_CallbackFunc_DefaultEEdit(EControl*, EEvent*)</a>
 <LI><a href="#[100e0e0]">EG_RedrawFunc_DefaultEExtLabel(EControl*)</a>
 <LI><a href="#[100e128]">EG_CallbackFunc_DefaultEExtLabel(EControl*, EEvent*)</a>
 <LI><a href="#[100e008]">EG_RedrawFunc_DefaultEComboBox(EControl*)</a>
 <LI><a href="#[100e050]">EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*)</a>
 <LI><a href="#[100dfc0]">EG_RedrawFunc_DefaultEIcon(EControl*)</a>
 <LI><a href="#[100df78]">EG_RedrawFunc_DefaultEIconButton(EControl*)</a>
 <LI><a href="#[100dea0]">EG_RedrawFunc_DefaultEMessageBox(EControl*)</a>
 <LI><a href="#[100dee8]">EG_CallbackFunc_DefaultEMessageBox(EControl*, EEvent*)</a>
 <LI><a href="#[100ddc8]">EG_RedrawFunc_DefaultEDialogBox(EControl*)</a>
 <LI><a href="#[100de10]">EG_CallbackFunc_DefaultEDialogBox(EControl*, EEvent*)</a>
 <LI><a href="#[100dd38]">EG_RedrawFunc_DefaultEScroll(EControl*)</a>
 <LI><a href="#[100dd80]">EG_CallbackFunc_DefaultEScroll(EControl*, EEvent*)</a>
 <LI><a href="#[100db88]">EG_RedrawFunc_DefaultEMenu(EControl*)</a>
 <LI><a href="#[100dbd0]">EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*)</a>
 <LI><a href="#[100db40]">EG_CallbackFunc_DefaultEPopupMenu(EControl*, EEvent*)</a>
 <LI><a href="#[100d708]">EG_RedrawFunc_DefaultEToolBar(EControl*)</a>
 <LI><a href="#[100d798]">EG_CallbackFunc_DefaultEToolBar(EControl*, EEvent*)</a>
 <LI><a href="#[bbfea0]">main</a>
 <LI><a href="#[11e8ff8]">__I_use_semihosting</a>
 <LI><a href="#[bbe230]">vTaskSwitchContext</a>
 <LI><a href="#[bb6698]">vTaskIncrementTick</a>
 <LI><a href="#[febc20]">ESimpleWindow::ForceRedrawAllControls()</a>
 <LI><a href="#[febbd8]">ESimpleWindow::RedrawSelectedControls()</a>
 <LI><a href="#[febb00]">ESimpleWindow::DispatchEvent(EEvent*)</a>
 <LI><a href="#[feadc8]">ESimpleWindow::InWindowArea(EPosition)</a>
 <LI><a href="#[fead80]">ESimpleWindow::RecoverWindow()</a>
 <LI><a href="#[fead38]">ESimpleWindow::GetWindowState()</a>
 <LI><a href="#[feb1b8]">ESimpleDesktop::DispatchEvent(EEvent*)</a>
 <LI><a href="#[feacf0]">ESimpleDesktop::RedrawDesktop()</a>
 <LI><a href="#[feb950]">EWindow::ForceRedrawAllControls()</a>
 <LI><a href="#[feb908]">EWindow::RedrawSelectedControls()</a>
 <LI><a href="#[feb5a8]">EWindow::DispatchEvent(EEvent*)</a>
 <LI><a href="#[feb3f8]">EWindow::InWindowArea(EPosition)</a>
 <LI><a href="#[feb4d0]">EWindow::RecoverWindow()</a>
 <LI><a href="#[feab88]">EWindow::GetWindowState()</a>
 <LI><a href="#[feae58]">EDesktop::DispatchEvent(EEvent*)</a>
 <LI><a href="#[feae10]">EDesktop::RedrawDesktop()</a>
 <LI><a href="#[101aed8]">__sti___11_GUIdemo_cpp</a>
</UL>
<P>
<H3>
Global Symbols
</H3>
<P><STRONG><a name="[bc3328]"></a>Reset_Handler</STRONG> (ARM, 0 bytes, Stack size unknown bytes, startup.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[fe54e0]"></a>__main</STRONG> (ARM, 8 bytes, Stack size 0 bytes, __main.o(!!!main))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + Unknown Stack Size
<LI>Call Chain = __main &rArr; __rt_entry &rArr; __rt_lib_init &rArr; _init_alloc &rArr; __rt_SIGRTMEM &rArr; __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
<LI><a href="#[11e4dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
</UL>

<P><STRONG><a name="[11e4dc8]"></a>__scatterload</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[fe54e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[11e4d80]"></a>__scatterload_rt2</STRONG> (ARM, 52 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11e4d38]"></a>__scatterload_null</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[11e4af8]"></a>__scatterload_copy</STRONG> (ARM, 40 bytes, Stack size unknown bytes, __scatter_copy.o(!!handler_copy), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11e4af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload_copy
</UL>
<BR>[Called By]<UL><LI><a href="#[11e4af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload_copy
</UL>

<P><STRONG><a name="[11e4990]"></a>__scatterload_zeroinit</STRONG> (ARM, 44 bytes, Stack size unknown bytes, __scatter_zi.o(!!handler_zi), UNUSED)

<P><STRONG><a name="[11e9e28]"></a>__ARM_argv_veneer</STRONG> (ARM, 16 bytes, Stack size 0 bytes, lib_init.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[bc3370]"></a>__user_initial_stackheap</STRONG> (ARM, 0 bytes, Stack size unknown bytes, startup.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11f0fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[bc2008]"></a>vParTestInitialise</STRONG> (ARM, 4 bytes, Stack size 0 bytes, partest.o(.text), UNUSED)

<P><STRONG><a name="[bc1fc0]"></a>vParTestSetLED</STRONG> (ARM, 48 bytes, Stack size 0 bytes, partest.o(.text), UNUSED)

<P><STRONG><a name="[bc1f78]"></a>vParTestToggleLED</STRONG> (ARM, 56 bytes, Stack size 0 bytes, partest.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1016458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vLEDFlashTask
</UL>

<P><STRONG><a name="[bbfea0]"></a>main</STRONG> (ARM, 100 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = main &rArr; vStartBlockingQueueTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbfc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPortInitMinimal
<LI><a href="#[bbfc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
<LI><a href="#[bbfca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartSemaphoreTasks
<LI><a href="#[bbfcf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartPolledQueueTasks
<LI><a href="#[bbfd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartLEDFlashTasks
<LI><a href="#[bbfd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartDynamicPriorityTasks
<LI><a href="#[bbfdc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartBlockingQueueTasks
<LI><a href="#[bbfe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vSerialPutString
<LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
<LI><a href="#[bc0b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSetupHardware
</UL>
<BR>[Address Reference Count : 1]<UL><LI> kernel.o(.text)
</UL>
<P><STRONG><a name="[bbfc18]"></a>xSerialPortInitMinimal</STRONG> (ARM, 276 bytes, Stack size 24 bytes, serial.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = xSerialPortInitMinimal &rArr; xQueueCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[bbe3e0]"></a>xSerialGetChar</STRONG> (ARM, 68 bytes, Stack size 16 bytes, serial.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>
<BR>[Called By]<UL><LI><a href="#[1019d68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vUARTCursorInfo
</UL>

<P><STRONG><a name="[bbe398]"></a>xSerialPutChar</STRONG> (ARM, 172 bytes, Stack size 32 bytes, serial.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104 + Unknown Stack Size
<LI>Call Chain = xSerialPutChar &rArr; xQueueGenericSend &rArr; prvUnlockQueue &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vSerialPutString
</UL>

<P><STRONG><a name="[bbfe10]"></a>vSerialPutString</STRONG> (ARM, 64 bytes, Stack size 24 bytes, serial.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = vSerialPutString &rArr; xSerialPutChar &rArr; xQueueGenericSend &rArr; prvUnlockQueue &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bbe398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPutChar
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[1019cd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nextButtonCBF(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[bbe350]"></a>vUART_ISRHandler</STRONG> (ARM, 272 bytes, Stack size 16 bytes, serial.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = vUART_ISRHandler &rArr; xQueueGenericSendFromISR &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bbe080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceiveFromISR
<LI><a href="#[bbe0c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
<LI><a href="#[bbe230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSwitchContext
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialisr.o(.text)
</UL>
<P><STRONG><a name="[bbe1e8]"></a>vUART_ISREntry</STRONG> (ARM, 0 bytes, Stack size unknown bytes, serialisr.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.text)
</UL>
<P><STRONG><a name="[bbc5f0]"></a>pvPortMalloc</STRONG> (ARM, 360 bytes, Stack size 24 bytes, heap_2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48 + Unknown Stack Size
<LI>Call Chain = pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[bb7100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAllocateTCBAndStack
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
<LI><a href="#[bbfca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartSemaphoreTasks
<LI><a href="#[bbfdc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartBlockingQueueTasks
</UL>

<P><STRONG><a name="[bbb070]"></a>vPortFree</STRONG> (ARM, 116 bytes, Stack size 16 bytes, heap_2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = vPortFree &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[bb70b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvDeleteTCB
<LI><a href="#[bb7100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAllocateTCBAndStack
<LI><a href="#[bb8728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueDelete
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
</UL>

<P><STRONG><a name="[bbb028]"></a>xPortGetFreeHeapSize</STRONG> (ARM, 12 bytes, Stack size 0 bytes, heap_2.o(.text), UNUSED)

<P><STRONG><a name="[bbafe0]"></a>vPortInitialiseBlocks</STRONG> (ARM, 4 bytes, Stack size 0 bytes, heap_2.o(.text), UNUSED)

<P><STRONG><a name="[bbc5a8]"></a>vListInitialise</STRONG> (ARM, 44 bytes, Stack size 0 bytes, list.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb7190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTaskLists
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
</UL>

<P><STRONG><a name="[bbc560]"></a>vListInitialiseItem</STRONG> (ARM, 12 bytes, Stack size 0 bytes, list.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb7148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTCBVariables
</UL>

<P><STRONG><a name="[bbc4d0]"></a>vListInsertEnd</STRONG> (ARM, 56 bytes, Stack size 0 bytes, list.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb6458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeFromISR
<LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
<LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[bb6578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPrioritySet
<LI><a href="#[bb6698]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskIncrementTick
<LI><a href="#[bb66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelete
<LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb8578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[bbc518]"></a>vListInsert</STRONG> (ARM, 92 bytes, Stack size 0 bytes, list.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bb8578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
</UL>

<P><STRONG><a name="[bbc488]"></a>vListRemove</STRONG> (ARM, 68 bytes, Stack size 0 bytes, list.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb6458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeFromISR
<LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
<LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[bb6578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPrioritySet
<LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bb6698]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskIncrementTick
<LI><a href="#[bb66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelete
<LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb8578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[bbe1a0]"></a>xQueueCreate</STRONG> (ARM, 180 bytes, Stack size 24 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = xQueueCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbb070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[bbc5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialise
<LI><a href="#[bbc5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPortInitMinimal
<LI><a href="#[bbfca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartSemaphoreTasks
<LI><a href="#[bbfcf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartPolledQueueTasks
<LI><a href="#[bbfd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartDynamicPriorityTasks
<LI><a href="#[bbfdc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartBlockingQueueTasks
</UL>

<P><STRONG><a name="[bbe110]"></a>xQueueGenericSend</STRONG> (ARM, 348 bytes, Stack size 48 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = xQueueGenericSend &rArr; prvUnlockQueue &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb84e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[bb8530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSetTimeOutState
<LI><a href="#[bb8578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bb90b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataToQueue
<LI><a href="#[bb9100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueFull
<LI><a href="#[bb9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPutChar
<LI><a href="#[bbfca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartSemaphoreTasks
<LI><a href="#[1010aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSemaphoreTest
<LI><a href="#[1013898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vBlockingQueueProducer
<LI><a href="#[1014ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueProducer
<LI><a href="#[1017ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueSendWhenSuspendedTask
</UL>

<P><STRONG><a name="[bbe0c8]"></a>xQueueGenericSendFromISR</STRONG> (ARM, 144 bytes, Stack size 32 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = xQueueGenericSendFromISR &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb90b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataToQueue
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vUART_ISRHandler
</UL>

<P><STRONG><a name="[bbe158]"></a>xQueueGenericReceive</STRONG> (ARM, 404 bytes, Stack size 48 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = xQueueGenericReceive &rArr; prvUnlockQueue &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb84e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[bb8530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSetTimeOutState
<LI><a href="#[bb8578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bb9028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataFromQueue
<LI><a href="#[bb9070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueEmpty
<LI><a href="#[bb9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPutChar
<LI><a href="#[bbe3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialGetChar
<LI><a href="#[1010aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSemaphoreTest
<LI><a href="#[10138e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vBlockingQueueConsumer
<LI><a href="#[1014ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueConsumer
<LI><a href="#[1017b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueReceiveWhenSuspendedTask
</UL>

<P><STRONG><a name="[bbe080]"></a>xQueueReceiveFromISR</STRONG> (ARM, 144 bytes, Stack size 24 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = xQueueReceiveFromISR &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb9028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataFromQueue
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vUART_ISRHandler
</UL>

<P><STRONG><a name="[bb87b8]"></a>uxQueueMessagesWaiting</STRONG> (ARM, 32 bytes, Stack size 16 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[1014ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueConsumer
</UL>

<P><STRONG><a name="[bb8770]"></a>uxQueueMessagesWaitingFromISR</STRONG> (ARM, 12 bytes, Stack size 0 bytes, queue.o(.text), UNUSED)

<P><STRONG><a name="[bb8728]"></a>vQueueDelete</STRONG> (ARM, 32 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbb070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
</UL>

<P><STRONG><a name="[bb86e0]"></a>xQueueIsQueueEmptyFromISR</STRONG> (ARM, 36 bytes, Stack size 0 bytes, queue.o(.text), UNUSED)

<P><STRONG><a name="[bb8698]"></a>xQueueIsQueueFullFromISR</STRONG> (ARM, 40 bytes, Stack size 0 bytes, queue.o(.text), UNUSED)

<P><STRONG><a name="[bb6728]"></a>xTaskGenericCreate</STRONG> (ARM, 420 bytes, Stack size 48 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 112 + Unknown Stack Size
<LI>Call Chain = xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pxPortInitialiseStack
<LI><a href="#[bb7100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAllocateTCBAndStack
<LI><a href="#[bb7148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTCBVariables
<LI><a href="#[bb7190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTaskLists
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
<LI><a href="#[bbfca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartSemaphoreTasks
<LI><a href="#[bbfcf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartPolledQueueTasks
<LI><a href="#[bbfd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartLEDFlashTasks
<LI><a href="#[bbfd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartDynamicPriorityTasks
<LI><a href="#[bbfdc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vStartBlockingQueueTasks
<LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
</UL>

<P><STRONG><a name="[bb66e0]"></a>vTaskDelete</STRONG> (ARM, 180 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>

<P><STRONG><a name="[bb6698]"></a>vTaskIncrementTick</STRONG> (ARM, 312 bytes, Stack size 8 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
</UL>
<BR>[Called By]<UL><LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>
<BR>[Address Reference Count : 1]<UL><LI> portasm.o(PORT_ASM)
</UL>
<P><STRONG><a name="[bbaf50]"></a>xTaskResumeAll</STRONG> (ARM, 344 bytes, Stack size 16 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6698]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskIncrementTick
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[bbb070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[bbc5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
<LI><a href="#[1017ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueSendWhenSuspendedTask
<LI><a href="#[1017b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueReceiveWhenSuspendedTask
</UL>

<P><STRONG><a name="[bbaf98]"></a>vTaskSuspendAll</STRONG> (ARM, 24 bytes, Stack size 0 bytes, tasks.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[bbb070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[bbc5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
<LI><a href="#[1017ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueSendWhenSuspendedTask
<LI><a href="#[1017b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueReceiveWhenSuspendedTask
</UL>

<P><STRONG><a name="[bb6650]"></a>vTaskDelayUntil</STRONG> (ARM, 252 bytes, Stack size 24 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[1016458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vLEDFlashTask
<LI><a href="#[1019d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIRedraw
</UL>

<P><STRONG><a name="[bb6608]"></a>vTaskDelay</STRONG> (ARM, 160 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[1010aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSemaphoreTest
<LI><a href="#[1014ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueConsumer
<LI><a href="#[1014ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueProducer
<LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
<LI><a href="#[1017ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueSendWhenSuspendedTask
</UL>

<P><STRONG><a name="[bb65c0]"></a>uxTaskPriorityGet</STRONG> (ARM, 60 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[10179e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vContinuousIncrementTask
</UL>

<P><STRONG><a name="[bb6578]"></a>vTaskPrioritySet</STRONG> (ARM, 252 bytes, Stack size 24 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[10179e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vContinuousIncrementTask
</UL>

<P><STRONG><a name="[bb6530]"></a>vTaskSuspend</STRONG> (ARM, 124 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[1017a30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vLimitedIncrementTask
<LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
</UL>

<P><STRONG><a name="[bb64e8]"></a>xTaskIsTaskSuspended</STRONG> (ARM, 128 bytes, Stack size 0 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[bb6458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeFromISR
<LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
</UL>

<P><STRONG><a name="[bb64a0]"></a>vTaskResume</STRONG> (ARM, 160 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb64e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIsTaskSuspended
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
</UL>

<P><STRONG><a name="[bb6458]"></a>xTaskResumeFromISR</STRONG> (ARM, 180 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb64e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIsTaskSuspended
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
</UL>

<P><STRONG><a name="[bbfc60]"></a>vTaskStartScheduler</STRONG> (ARM, 100 bytes, Stack size 24 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = vTaskStartScheduler &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
<LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[bb6410]"></a>vTaskEndScheduler</STRONG> (ARM, 40 bytes, Stack size 8 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb62a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEndScheduler
</UL>

<P><STRONG><a name="[bbc440]"></a>xTaskGetTickCount</STRONG> (ARM, 32 bytes, Stack size 8 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[1016458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vLEDFlashTask
<LI><a href="#[1019d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIRedraw
</UL>

<P><STRONG><a name="[bb63c8]"></a>uxTaskGetNumberOfTasks</STRONG> (ARM, 12 bytes, Stack size 0 bytes, tasks.o(.text), UNUSED)

<P><STRONG><a name="[bbe230]"></a>vTaskSwitchContext</STRONG> (ARM, 164 bytes, Stack size 0 bytes, tasks.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bbe350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vUART_ISRHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> portasm.o(PORT_ASM)
</UL>
<P><STRONG><a name="[bb8578]"></a>vTaskPlaceOnEventList</STRONG> (ARM, 264 bytes, Stack size 16 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = vTaskPlaceOnEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[bbc518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb84a0]"></a>xTaskRemoveFromEventList</STRONG> (ARM, 192 bytes, Stack size 16 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbc4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
</UL>
<BR>[Called By]<UL><LI><a href="#[bb9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[bbe080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceiveFromISR
<LI><a href="#[bbe0c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb8530]"></a>vTaskSetTimeOutState</STRONG> (ARM, 28 bytes, Stack size 0 bytes, tasks.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb84e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb84e8]"></a>xTaskCheckForTimeOut</STRONG> (ARM, 176 bytes, Stack size 16 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = xTaskCheckForTimeOut
</UL>
<BR>[Calls]<UL><LI><a href="#[bb8530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSetTimeOutState
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb85c0]"></a>vTaskMissedYield</STRONG> (ARM, 16 bytes, Stack size 0 bytes, tasks.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
</UL>

<P><STRONG><a name="[bb6338]"></a>pxPortInitialiseStack</STRONG> (ARM, 232 bytes, Stack size 0 bytes, port.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
</UL>

<P><STRONG><a name="[bb6260]"></a>xPortStartScheduler</STRONG> (ARM, 24 bytes, Stack size 8 bytes, port.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = xPortStartScheduler
</UL>
<BR>[Calls]<UL><LI><a href="#[bb5288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSetupTimerInterrupt
<LI><a href="#[bb5db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortStartFirstTask
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
</UL>

<P><STRONG><a name="[bb62a8]"></a>vPortEndScheduler</STRONG> (ARM, 4 bytes, Stack size 0 bytes, port.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[bb6410]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskEndScheduler
</UL>

<P><STRONG><a name="[bbe2c0]"></a>vPortEnterCritical</STRONG> (ARM, 36 bytes, Stack size 0 bytes, port.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
<LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[bb6578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPrioritySet
<LI><a href="#[bb65c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxTaskPriorityGet
<LI><a href="#[bb66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelete
<LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[bb84e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[bb87b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxQueueMessagesWaiting
<LI><a href="#[bb9070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueEmpty
<LI><a href="#[bb9100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueFull
<LI><a href="#[bb9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbc440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetTickCount
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[bbe398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPutChar
<LI><a href="#[bbfc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPortInitMinimal
<LI><a href="#[1010aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSemaphoreTest
<LI><a href="#[1014ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueConsumer
<LI><a href="#[1014ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueProducer
<LI><a href="#[1016458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vLEDFlashTask
<LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
</UL>

<P><STRONG><a name="[bbe278]"></a>vPortExitCritical</STRONG> (ARM, 68 bytes, Stack size 0 bytes, port.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
<LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[bb6578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPrioritySet
<LI><a href="#[bb65c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxTaskPriorityGet
<LI><a href="#[bb66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelete
<LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[bb84e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[bb87b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxQueueMessagesWaiting
<LI><a href="#[bb9070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueEmpty
<LI><a href="#[bb9100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueFull
<LI><a href="#[bb9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbc440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetTickCount
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[bbe398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPutChar
<LI><a href="#[bbfc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPortInitMinimal
<LI><a href="#[1010aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSemaphoreTest
<LI><a href="#[1014ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueConsumer
<LI><a href="#[1014ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPolledQueueProducer
<LI><a href="#[1016458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vLEDFlashTask
<LI><a href="#[1017a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vCounterControlTask
</UL>

<P><STRONG><a name="[1019d68]"></a>vUARTCursorInfo</STRONG> (ARM, 256 bytes, Stack size 8 bytes, guidemo.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialGetChar
</UL>

<P><STRONG><a name="[1019d20]"></a>vGUIRedraw</STRONG> (ARM, 44 bytes, Stack size 8 bytes, guidemo.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bbc440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetTickCount
<LI><a href="#[1019780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::ScheduleRedraw()
</UL>

<P><STRONG><a name="[bbfe58]"></a>vGUIInit</STRONG> (ARM, 148 bytes, Stack size 24 bytes, guidemo.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = vGUIInit &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[1019738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::AddWindow(ESimpleWindow*)
<LI><a href="#[10197c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::GlobalRedraw()
<LI><a href="#[10198a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearBuffer()
<LI><a href="#[10198e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDInit()
<LI><a href="#[1019c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::AddControl(EControl*)
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1019cd8]"></a>nextButtonCBF(EControl*, EEvent*)</STRONG> (ARM, 332 bytes, Stack size 16 bytes, guidemo.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbfe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vSerialPutString
<LI><a href="#[10196a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::AddCharToString(char)
<LI><a href="#[1019810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::RemoveControl(int)
<LI><a href="#[1019c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::AddControl(EControl*)
</UL>

<P><STRONG><a name="[bbfd80]"></a>vStartDynamicPriorityTasks</STRONG> (ARM, 224 bytes, Stack size 24 bytes, dynamic.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = vStartDynamicPriorityTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10170a0]"></a>xAreDynamicPriorityTasksStillRunning</STRONG> (ARM, 92 bytes, Stack size 0 bytes, dynamic.o(.text), UNUSED)

<P><STRONG><a name="[bbfd38]"></a>vStartLEDFlashTasks</STRONG> (ARM, 72 bytes, Stack size 32 bytes, flash.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = vStartLEDFlashTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[bbfcf0]"></a>vStartPolledQueueTasks</STRONG> (ARM, 116 bytes, Stack size 24 bytes, pollq.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = vStartPolledQueueTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1014638]"></a>xArePollingQueuesStillRunning</STRONG> (ARM, 68 bytes, Stack size 0 bytes, pollq.o(.text), UNUSED)

<P><STRONG><a name="[bbfdc8]"></a>vStartBlockingQueueTasks</STRONG> (ARM, 532 bytes, Stack size 64 bytes, blockq.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = vStartBlockingQueueTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bbc5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1013028]"></a>xAreBlockingQueuesStillRunning</STRONG> (ARM, 228 bytes, Stack size 0 bytes, blockq.o(.text), UNUSED)

<P><STRONG><a name="[bbfca8]"></a>vStartSemaphoreTasks</STRONG> (ARM, 404 bytes, Stack size 40 bytes, semtest.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 152 + Unknown Stack Size
<LI>Call Chain = vStartSemaphoreTasks &rArr; xTaskGenericCreate &rArr; prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bbc5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10101a8]"></a>xAreSemaphoreTasksStillRunning</STRONG> (ARM, 88 bytes, Stack size 0 bytes, semtest.o(.text), UNUSED)

<P><STRONG><a name="[100e368]"></a>EG_RedrawFunc_DefaultELabel(EControl*)</STRONG> (ARM, 52 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = EG_RedrawFunc_DefaultELabel(EControl*) &rArr; EG_Graphic_DrawString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e320]"></a>EG_RedrawFunc_DefaultEButton(EControl*)</STRONG> (ARM, 84 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = EG_RedrawFunc_DefaultEButton(EControl*) &rArr; EG_Graphic_DrawString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e2d8]"></a>EG_CallbackFunc_DefaultECheckButton(EControl*, EEvent*)</STRONG> (ARM, 96 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EG_CallbackFunc_DefaultECheckButton(EControl*, EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e290]"></a>EG_RedrawFunc_DefaultECheckButton(EControl*)</STRONG> (ARM, 180 bytes, Stack size 24 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = EG_RedrawFunc_DefaultECheckButton(EControl*) &rArr; EG_Graphic_DrawString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[10196a8]"></a>EEdit::AddCharToString(char)</STRONG> (ARM, 68 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EEdit::AddCharToString(char) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[100e248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEEdit(EControl*, EEvent*)
<LI><a href="#[1019cd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nextButtonCBF(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100e248]"></a>EG_CallbackFunc_DefaultEEdit(EControl*, EEvent*)</STRONG> (ARM, 68 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = EG_CallbackFunc_DefaultEEdit(EControl*, EEvent*) &rArr; EEdit::AddCharToString(char) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[10196a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::AddCharToString(char)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e200]"></a>EG_RedrawFunc_DefaultEEdit(EControl*)</STRONG> (ARM, 192 bytes, Stack size 32 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = EG_RedrawFunc_DefaultEEdit(EControl*) &rArr; EG_Graphic_DrawConstString(unsigned, unsigned, char*, unsigned char) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff01a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawConstString(unsigned, unsigned, char*, unsigned char)
<LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e1b8]"></a>EG_RedrawFunc_DefaultEProgress(EControl*)</STRONG> (ARM, 164 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100e170]"></a>EExtLabel::ChangeState()</STRONG> (ARM, 56 bytes, Stack size 8 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EExtLabel::ChangeState() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[100e128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEExtLabel(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100e128]"></a>EG_CallbackFunc_DefaultEExtLabel(EControl*, EEvent*)</STRONG> (ARM, 72 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EG_CallbackFunc_DefaultEExtLabel(EControl*, EEvent*) &rArr; EExtLabel::ChangeState() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100e170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EExtLabel::ChangeState()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e0e0]"></a>EG_RedrawFunc_DefaultEExtLabel(EControl*)</STRONG> (ARM, 80 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = EG_RedrawFunc_DefaultEExtLabel(EControl*) &rArr; EG_Graphic_DrawNotString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawNotChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff01e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotString(unsigned, unsigned, char*)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e098]"></a>EComboBox::SwitchOpenState()</STRONG> (ARM, 84 bytes, Stack size 8 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EComboBox::SwitchOpenState() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[100e050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100e050]"></a>EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*)</STRONG> (ARM, 208 bytes, Stack size 40 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*) &rArr; EComboBox::SetSelectIndex(unsigned) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[ff0428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::SetSelectIndex(unsigned)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100e098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::SwitchOpenState()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100e008]"></a>EG_RedrawFunc_DefaultEComboBox(EControl*)</STRONG> (ARM, 468 bytes, Stack size 24 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = EG_RedrawFunc_DefaultEComboBox(EControl*) &rArr; EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[ff0470]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::GetItemString(unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100dfc0]"></a>EG_RedrawFunc_DefaultEIcon(EControl*)</STRONG> (ARM, 68 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = EG_RedrawFunc_DefaultEIcon(EControl*) &rArr; EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff02c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100df78]"></a>EG_RedrawFunc_DefaultEIconButton(EControl*)</STRONG> (ARM, 180 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = EG_RedrawFunc_DefaultEIconButton(EControl*) &rArr; EG_Graphic_DrawString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[ff02c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100df30]"></a>EMessageBox::InCloseArea(const EPosition&)</STRONG> (ARM, 104 bytes, Stack size 0 bytes, econtrol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[100dee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEMessageBox(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100dee8]"></a>EG_CallbackFunc_DefaultEMessageBox(EControl*, EEvent*)</STRONG> (ARM, 104 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EG_CallbackFunc_DefaultEMessageBox(EControl*, EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100df30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMessageBox::InCloseArea(const EPosition&)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100dea0]"></a>EG_RedrawFunc_DefaultEMessageBox(EControl*)</STRONG> (ARM, 224 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = EG_RedrawFunc_DefaultEMessageBox(EControl*) &rArr; EG_Graphic_DrawNotString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawNotChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff01e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotString(unsigned, unsigned, char*)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100de58]"></a>EDialogBox::UpdataState(const EPosition&)</STRONG> (ARM, 184 bytes, Stack size 0 bytes, econtrol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[100de10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEDialogBox(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100de10]"></a>EG_CallbackFunc_DefaultEDialogBox(EControl*, EEvent*)</STRONG> (ARM, 104 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EG_CallbackFunc_DefaultEDialogBox(EControl*, EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100de58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDialogBox::UpdataState(const EPosition&)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100ddc8]"></a>EG_RedrawFunc_DefaultEDialogBox(EControl*)</STRONG> (ARM, 368 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = EG_RedrawFunc_DefaultEDialogBox(EControl*) &rArr; EG_Graphic_DrawNotString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawNotChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff01e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotString(unsigned, unsigned, char*)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100dd80]"></a>EG_CallbackFunc_DefaultEScroll(EControl*, EEvent*)</STRONG> (ARM, 208 bytes, Stack size 24 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EG_CallbackFunc_DefaultEScroll(EControl*, EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100dd38]"></a>EG_RedrawFunc_DefaultEScroll(EControl*)</STRONG> (ARM, 444 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = EG_RedrawFunc_DefaultEScroll(EControl*) &rArr; EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100dcf0]"></a>EG_CallbackFunc_DefaultEList(EControl*, EEvent*)</STRONG> (ARM, 200 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100dca8]"></a>EG_RedrawFunc_DefaultEList(EControl*)</STRONG> (ARM, 248 bytes, Stack size 32 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>

<P><STRONG><a name="[100dc60]"></a>EMenu::UpdateHeightAndPosition()</STRONG> (ARM, 80 bytes, Stack size 0 bytes, econtrol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[100dc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::SwitchShowState()
</UL>

<P><STRONG><a name="[100dc18]"></a>EMenu::SwitchShowState()</STRONG> (ARM, 168 bytes, Stack size 8 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EMenu::SwitchShowState() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100dc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::UpdateHeightAndPosition()
</UL>
<BR>[Called By]<UL><LI><a href="#[100dbd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100dbd0]"></a>EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*)</STRONG> (ARM, 596 bytes, Stack size 32 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48 + Unknown Stack Size
<LI>Call Chain = EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*) &rArr; EMenu::SwitchShowState() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[ff0788]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::SetSelectItem(unsigned)
<LI><a href="#[100dc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::SwitchShowState()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100db88]"></a>EG_RedrawFunc_DefaultEMenu(EControl*)</STRONG> (ARM, 556 bytes, Stack size 24 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = EG_RedrawFunc_DefaultEMenu(EControl*) &rArr; EG_Graphic_DrawNotString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawNotChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff01e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotString(unsigned, unsigned, char*)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100db40]"></a>EG_CallbackFunc_DefaultEPopupMenu(EControl*, EEvent*)</STRONG> (ARM, 304 bytes, Stack size 32 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = EG_CallbackFunc_DefaultEPopupMenu(EControl*, EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100daf8]"></a>EG_RedrawFunc_DefaultEPopupMenu(EControl*)</STRONG> (ARM, 236 bytes, Stack size 32 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff01e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotString(unsigned, unsigned, char*)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>

<P><STRONG><a name="[100dab0]"></a>ETree::ETreeItem::OpenAllSubItem()</STRONG> (ARM, 68 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff06b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::OpenSubItem()
</UL>
<BR>[Called By]<UL><LI><a href="#[ff06b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::OpenSubItem()
</UL>

<P><STRONG><a name="[100da68]"></a>ETree::ETreeItem::CloseAllSubItem()</STRONG> (ARM, 68 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::CloseSubItem()
</UL>
<BR>[Called By]<UL><LI><a href="#[ff0668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::CloseSubItem()
</UL>

<P><STRONG><a name="[100da20]"></a>ETree::ETreeSubItem::GetOpenSubItem(unsigned&)</STRONG> (ARM, 104 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100d9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItem(unsigned&)
</UL>
<BR>[Called By]<UL><LI><a href="#[100d9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItem(unsigned&)
</UL>

<P><STRONG><a name="[100d9d8]"></a>ETree::ETreeItem::GetOpenSubItem(unsigned&)</STRONG> (ARM, 108 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100da20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::GetOpenSubItem(unsigned&)
</UL>
<BR>[Called By]<UL><LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100d990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultETree(EControl*, EEvent*)
<LI><a href="#[100da20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::GetOpenSubItem(unsigned&)
</UL>

<P><STRONG><a name="[100d990]"></a>EG_CallbackFunc_DefaultETree(EControl*, EEvent*)</STRONG> (ARM, 200 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[ff0668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::CloseSubItem()
<LI><a href="#[ff06b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::OpenSubItem()
<LI><a href="#[100d9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItem(unsigned&)
</UL>

<P><STRONG><a name="[100d948]"></a>ETree::DrawExtendIcon(const EPosition&, bool)</STRONG> (ARM, 96 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
</UL>

<P><STRONG><a name="[100d900]"></a>ETree::ETreeSubItem::GetOpenSubItemCount()</STRONG> (ARM, 44 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100d8b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItemCount()
</UL>
<BR>[Called By]<UL><LI><a href="#[100d8b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItemCount()
</UL>

<P><STRONG><a name="[100d8b8]"></a>ETree::ETreeItem::GetOpenSubItemCount()</STRONG> (ARM, 88 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100d900]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::GetOpenSubItemCount()
</UL>
<BR>[Called By]<UL><LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100d900]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::GetOpenSubItemCount()
</UL>

<P><STRONG><a name="[100d870]"></a>EG_RedrawFunc_DefaultETree(EControl*)</STRONG> (ARM, 612 bytes, Stack size 40 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[100d8b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItemCount()
<LI><a href="#[100d948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::DrawExtendIcon(const EPosition&, bool)
<LI><a href="#[100d9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::GetOpenSubItem(unsigned&)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100d828]"></a>EControl::NoticeControl(EEvent*)</STRONG> (ARM, 72 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EControl::NoticeControl(EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
<LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
<LI><a href="#[febb00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::DispatchEvent(EEvent*)
<LI><a href="#[100d798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEToolBar(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100d7e0]"></a>EControl::InControlArea(EPosition)</STRONG> (ARM, 92 bytes, Stack size 12 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = EControl::InControlArea(EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
<LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
<LI><a href="#[febb48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::SelectControl(EPosition)
<LI><a href="#[febb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::RedrawControl(const EPosition&)
<LI><a href="#[100d798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEToolBar(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100d798]"></a>EG_CallbackFunc_DefaultEToolBar(EControl*, EEvent*)</STRONG> (ARM, 132 bytes, Stack size 24 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = EG_CallbackFunc_DefaultEToolBar(EControl*, EEvent*) &rArr; EControl::NoticeControl(EEvent*) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100d7e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::InControlArea(EPosition)
<LI><a href="#[100d828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::NoticeControl(EEvent*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100d750]"></a>EToolBar::AdjustControlPosition()</STRONG> (ARM, 96 bytes, Stack size 0 bytes, econtrol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[feb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustBarPosition()
<LI><a href="#[100d708]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEToolBar(EControl*)
</UL>

<P><STRONG><a name="[100d708]"></a>EG_RedrawFunc_DefaultEToolBar(EControl*)</STRONG> (ARM, 104 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = EG_RedrawFunc_DefaultEToolBar(EControl*) &rArr; EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100d750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::AdjustControlPosition()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> econtrol.o(.text)
</UL>
<P><STRONG><a name="[100d6c0]"></a>EG_RedrawFunc_DefaultEStatusBar(EControl*)</STRONG> (ARM, 164 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
</UL>

<P><STRONG><a name="[100d678]"></a>EBarChart::CheckSelectItem(unsigned, unsigned)</STRONG> (ARM, 256 bytes, Stack size 20 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[100d630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEBarChart(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[100d630]"></a>EG_CallbackFunc_DefaultEBarChart(EControl*, EEvent*)</STRONG> (ARM, 120 bytes, Stack size 32 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100d678]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EBarChart::CheckSelectItem(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100d5e8]"></a>EG_RedrawFunc_DefaultEBarChart(EControl*)</STRONG> (ARM, 976 bytes, Stack size 40 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[ff0278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNumber(unsigned, unsigned, int)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
</UL>

<P><STRONG><a name="[100d5a0]"></a>EG_RedrawFunc_DefaultEClock(EControl*)</STRONG> (ARM, 252 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNumber(unsigned, unsigned, int)
<LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
</UL>

<P><STRONG><a name="[1019618]"></a>ELabel::ELabel(EPosition, char*, unsigned)</STRONG> (ARM, 116 bytes, Stack size 56 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ELabel::ELabel(EPosition, char*, unsigned) &rArr; EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[100d558]"></a>ELabel::ELabel__sub_object(EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d510]"></a>ELabel::ELabel(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)</STRONG> (ARM, 132 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[100d048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EExtLabel::EExtLabel(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)
<LI><a href="#[100d0d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EExtLabel::EExtLabel(EPosition, char*, unsigned)
<LI><a href="#[100d168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EExtLabel::EExtLabel()
</UL>

<P><STRONG><a name="[100d4c8]"></a>ELabel::ELabel__sub_object(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[10195d0]"></a>EButton::EButton(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)</STRONG> (ARM, 124 bytes, Stack size 64 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = EButton::EButton(void(*)(EControl*, EEvent*), EPosition, char*, unsigned) &rArr; EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[100d480]"></a>EButton::EButton__sub_object(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[1019858]"></a>ECheckButton::ECheckButton(bool, EPosition, char*, unsigned)</STRONG> (ARM, 128 bytes, Stack size 64 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = ECheckButton::ECheckButton(bool, EPosition, char*, unsigned) &rArr; EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[100d438]"></a>ECheckButton::ECheckButton__sub_object(bool, EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d3f0]"></a>ECheckButton::ECheckButton(void(*)(EControl*, EEvent*), bool, EPosition, char*, unsigned)</STRONG> (ARM, 140 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100d3a8]"></a>ECheckButton::ECheckButton__sub_object(void(*)(EControl*, EEvent*), bool, EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[1019660]"></a>EEdit::EEdit(bool, EPosition, unsigned)</STRONG> (ARM, 152 bytes, Stack size 56 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = EEdit::EEdit(bool, EPosition, unsigned) &rArr; EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[100d360]"></a>EEdit::EEdit__sub_object(bool, EPosition, unsigned)</STRONG> (ARM, 0 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d318]"></a>EEdit::SetString(char*)</STRONG> (ARM, 100 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[100d240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(void(*)(EControl*, EEvent*), char*, bool, EPosition, unsigned)
<LI><a href="#[100d2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(char*, bool, EPosition, unsigned)
</UL>

<P><STRONG><a name="[100d2d0]"></a>EEdit::EEdit(char*, bool, EPosition, unsigned)</STRONG> (ARM, 176 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[100d318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::SetString(char*)
</UL>

<P><STRONG><a name="[100d288]"></a>EEdit::EEdit__sub_object(char*, bool, EPosition, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d240]"></a>EEdit::EEdit(void(*)(EControl*, EEvent*), char*, bool, EPosition, unsigned)</STRONG> (ARM, 172 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[100d318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::SetString(char*)
</UL>

<P><STRONG><a name="[100d1f8]"></a>EEdit::EEdit__sub_object(void(*)(EControl*, EEvent*), char*, bool, EPosition, unsigned)</STRONG> (ARM, 0 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d1b0]"></a>EEdit::SetString(char*, int)</STRONG> (ARM, 100 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100d168]"></a>EExtLabel::EExtLabel()</STRONG> (ARM, 100 bytes, Stack size 32 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100d510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100d120]"></a>EExtLabel::EExtLabel__sub_object()</STRONG> (ARM, 0 bytes, Stack size 32 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d0d8]"></a>EExtLabel::EExtLabel(EPosition, char*, unsigned)</STRONG> (ARM, 80 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100d510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)
</UL>

<P><STRONG><a name="[100d090]"></a>EExtLabel::EExtLabel__sub_object(EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100d048]"></a>EExtLabel::EExtLabel(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)</STRONG> (ARM, 84 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100d510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)
</UL>

<P><STRONG><a name="[100d000]"></a>EExtLabel::EExtLabel__sub_object(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100cfb8]"></a>EComboBox::EComboBox()</STRONG> (ARM, 132 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))
</UL>

<P><STRONG><a name="[100cf70]"></a>EComboBox::EComboBox__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100cf28]"></a>EComboBox::EComboBox(EPosition, unsigned)</STRONG> (ARM, 188 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100cee0]"></a>EComboBox::EComboBox__sub_object(EPosition, unsigned)</STRONG> (ARM, 0 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100ce98]"></a>EComboBox::SetIemString(unsigned, char*)</STRONG> (ARM, 76 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100ce50]"></a>EComboBox::AddItem(char*)</STRONG> (ARM, 88 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100ce08]"></a>EComboBox::RemoveItem(unsigned)</STRONG> (ARM, 128 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100cdc0]"></a>EIcon::SetIconBuffer(unsigned)</STRONG> (ARM, 32 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[100cd78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIcon::EIcon(void(*)(EControl*, EEvent*), EPosition, unsigned)
</UL>

<P><STRONG><a name="[100cd78]"></a>EIcon::EIcon(void(*)(EControl*, EEvent*), EPosition, unsigned)</STRONG> (ARM, 156 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[100cdc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIcon::SetIconBuffer(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[100cbc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIconButton::EIconButton(void(*)(EControl*, EEvent*), EPosition, ESize, unsigned, char*, bool)
</UL>

<P><STRONG><a name="[100cd30]"></a>EIcon::EIcon__sub_object(void(*)(EControl*, EEvent*), EPosition, unsigned)</STRONG> (ARM, 0 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100cca0]"></a>EIconButton::EIconButton(void(*)(EControl*, EEvent*), EPosition, ESize, ESize, unsigned char*, char*, bool)</STRONG> (ARM, 200 bytes, Stack size 72 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff05d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::SetRedrawFunction(void(*)(EControl*))
</UL>

<P><STRONG><a name="[100cc10]"></a>EIconButton::EIconButton__sub_object(void(*)(EControl*, EEvent*), EPosition, ESize, ESize, unsigned char*, char*, bool)</STRONG> (ARM, 0 bytes, Stack size 72 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100cbc8]"></a>EIconButton::EIconButton(void(*)(EControl*, EEvent*), EPosition, ESize, unsigned, char*, bool)</STRONG> (ARM, 124 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff05d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::SetRedrawFunction(void(*)(EControl*))
<LI><a href="#[100cd78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIcon::EIcon(void(*)(EControl*, EEvent*), EPosition, unsigned)
</UL>

<P><STRONG><a name="[100cb80]"></a>EIconButton::EIconButton__sub_object(void(*)(EControl*, EEvent*), EPosition, ESize, unsigned, char*, bool)</STRONG> (ARM, 0 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100cb38]"></a>EMessageBox::EMessageBox(unsigned char, EPosition, char*, unsigned)</STRONG> (ARM, 128 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100caf0]"></a>EMessageBox::EMessageBox__sub_object(unsigned char, EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100caa8]"></a>EMessageBox::SwitchState()</STRONG> (ARM, 56 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100ca60]"></a>EDialogBox::EDialogBox(unsigned char, EPosition, char*, unsigned)</STRONG> (ARM, 148 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100ca18]"></a>EDialogBox::EDialogBox__sub_object(unsigned char, EPosition, char*, unsigned)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c9d0]"></a>EScroll::EScroll()</STRONG> (ARM, 56 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))
</UL>

<P><STRONG><a name="[100c988]"></a>EScroll::EScroll__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c940]"></a>EScroll::EScroll(EPosition, unsigned, unsigned)</STRONG> (ARM, 112 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100c8f8]"></a>EScroll::EScroll__sub_object(EPosition, unsigned, unsigned)</STRONG> (ARM, 0 bytes, Stack size 56 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c8b0]"></a>EScroll::SetCurrentPosition(unsigned)</STRONG> (ARM, 60 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c868]"></a>EList::AddItem(EList::EListItem*)</STRONG> (ARM, 84 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c820]"></a>EList::RemoveItem(int)</STRONG> (ARM, 112 bytes, Stack size 4 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c7d8]"></a>EList::RemoveAllItems()</STRONG> (ARM, 56 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c790]"></a>EList::AddColumn(unsigned)</STRONG> (ARM, 172 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c748]"></a>EList::SetColumnWidth(unsigned, unsigned)</STRONG> (ARM, 88 bytes, Stack size 4 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c700]"></a>EList::SetItem(unsigned, unsigned, char*)</STRONG> (ARM, 112 bytes, Stack size 12 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c6b8]"></a>EList::SetItem(unsigned, unsigned, char*, void(*)(EControl*, EEvent*))</STRONG> (ARM, 128 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c670]"></a>EMenu::EMenu()</STRONG> (ARM, 180 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100c628]"></a>EMenu::EMenu__sub_object()</STRONG> (ARM, 0 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c5e0]"></a>EMenu::EMenu(char*, unsigned, EPosition, bool)</STRONG> (ARM, 204 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100c598]"></a>EMenu::EMenu__sub_object(char*, unsigned, EPosition, bool)</STRONG> (ARM, 0 bytes, Stack size 64 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c550]"></a>EMenu::AddItem(EMenu::EMenuItem*)</STRONG> (ARM, 148 bytes, Stack size 4 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c508]"></a>EMenu::RemovedAllItems()</STRONG> (ARM, 60 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c4c0]"></a>EMenu::SetMenuItemState(unsigned, unsigned char)</STRONG> (ARM, 36 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c478]"></a>EMenu::SetMenuItem(unsigned, char*, unsigned char)</STRONG> (ARM, 168 bytes, Stack size 12 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c430]"></a>EMenu::SetMenuItem(unsigned, char*, unsigned char, void(*)(EControl*, EEvent*))</STRONG> (ARM, 172 bytes, Stack size 12 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c3e8]"></a>EMenu::CollapseMenu()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[feaee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::AppendStartMenu(EMenu*)
</UL>

<P><STRONG><a name="[100c3a0]"></a>EPopupMenu::EPopupMenu()</STRONG> (ARM, 116 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
</UL>

<P><STRONG><a name="[100c358]"></a>EPopupMenu::EPopupMenu__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c310]"></a>EPopupMenu::AddItem(EPopupMenu::EPopupMenuItem*)</STRONG> (ARM, 132 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c2c8]"></a>EPopupMenu::RemovedAllItems()</STRONG> (ARM, 52 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c280]"></a>EPopupMenu::SetPopupMenuItemState(unsigned, unsigned char)</STRONG> (ARM, 36 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c238]"></a>EPopupMenu::SetPopupMenuItem(unsigned, char*, unsigned char)</STRONG> (ARM, 148 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c1f0]"></a>EPopupMenu::SetPopupMenuItem(unsigned, char*, unsigned char, void(*)(EControl*, EEvent*))</STRONG> (ARM, 164 bytes, Stack size 12 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c1a8]"></a>EPopupMenu::ShowPopupMenu(const EPosition&)</STRONG> (ARM, 80 bytes, Stack size 16 bytes, econtrol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EPopupMenu::ShowPopupMenu(const EPosition&) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
<LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[100c160]"></a>EPopupMenu::ClosePopupMenu()</STRONG> (ARM, 20 bytes, Stack size 0 bytes, econtrol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
<LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[100c118]"></a>ETree::ETreeItem::AddSubItem(ETree::ETreeSubItem*)</STRONG> (ARM, 64 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[100bf68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::AddLeaf(unsigned, unsigned, ETree::ETreeSubItem*, char*)
<LI><a href="#[100bff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::AddLeaf(unsigned, ETree::ETreeSubItem*, char*)
<LI><a href="#[100c0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::AddRoot(ETree::ETreeSubItem*, char*)
</UL>

<P><STRONG><a name="[100c0d0]"></a>ETree::AddRoot(ETree::ETreeSubItem*, char*)</STRONG> (ARM, 140 bytes, Stack size 20 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100c118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::AddSubItem(ETree::ETreeSubItem*)
</UL>

<P><STRONG><a name="[100c088]"></a>ETree::AddBranch(ETree::ETreeItem*, unsigned)</STRONG> (ARM, 36 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100c040]"></a>ETree::AddBranch(ETree::ETreeItem*, unsigned, unsigned)</STRONG> (ARM, 72 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bff8]"></a>ETree::AddLeaf(unsigned, ETree::ETreeSubItem*, char*)</STRONG> (ARM, 208 bytes, Stack size 24 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100c118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::AddSubItem(ETree::ETreeSubItem*)
</UL>

<P><STRONG><a name="[100bfb0]"></a>ETree::ETreeSubItem::SetSubItemString(char*)</STRONG> (ARM, 68 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[100bf68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::AddLeaf(unsigned, unsigned, ETree::ETreeSubItem*, char*)
</UL>

<P><STRONG><a name="[100bf68]"></a>ETree::AddLeaf(unsigned, unsigned, ETree::ETreeSubItem*, char*)</STRONG> (ARM, 188 bytes, Stack size 28 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100bfb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeSubItem::SetSubItemString(char*)
<LI><a href="#[100c118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::AddSubItem(ETree::ETreeSubItem*)
</UL>

<P><STRONG><a name="[100bf20]"></a>ETree::RemoveAllRoots()</STRONG> (ARM, 44 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bed8]"></a>ETree::RemoveRoot(unsigned)</STRONG> (ARM, 68 bytes, Stack size 4 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100be90]"></a>ETree::ToggleRootState(unsigned)</STRONG> (ARM, 96 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100be48]"></a>ETree::ToggleLeafState(unsigned, unsigned)</STRONG> (ARM, 156 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>

<P><STRONG><a name="[100be00]"></a>ETree::ETreeSubItem::ETreeSubItem()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bdb8]"></a>ETree::ETreeSubItem::ETreeSubItem__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bd70]"></a>ETree::ETreeItem::ETreeItem()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bd28]"></a>ETree::ETreeItem::ETreeItem__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bce0]"></a>EToolBar::RemoveAllItems()</STRONG> (ARM, 56 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[100bc08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::EToolBar(EPosition)
<LI><a href="#[100bc98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::EToolBar()
</UL>

<P><STRONG><a name="[100bc98]"></a>EToolBar::EToolBar()</STRONG> (ARM, 60 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))
<LI><a href="#[100bce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::RemoveAllItems()
</UL>

<P><STRONG><a name="[100bc50]"></a>EToolBar::EToolBar__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[100bc08]"></a>EToolBar::EToolBar(EPosition)</STRONG> (ARM, 112 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[100bce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::RemoveAllItems()
</UL>

<P><STRONG><a name="[100bbc0]"></a>EToolBar::EToolBar__sub_object(EPosition)</STRONG> (ARM, 0 bytes, Stack size 48 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff0a58]"></a>EToolBar::AddItem(EControl*)</STRONG> (ARM, 116 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff0a10]"></a>EToolBar::UpdateToolBarHeight()</STRONG> (ARM, 84 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[ff09c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::RemoveItem(unsigned)
</UL>

<P><STRONG><a name="[ff09c8]"></a>EToolBar::RemoveItem(unsigned)</STRONG> (ARM, 152 bytes, Stack size 16 bytes, econtrol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::UpdateToolBarHeight()
</UL>

<P><STRONG><a name="[ff0980]"></a>EToolBar::SetDockState(unsigned char)</STRONG> (ARM, 88 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff0938]"></a>EStatusBar::SetLabelString(char*)</STRONG> (ARM, 84 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff08f0]"></a>EStatusBar::SetStatusString(char*, unsigned char)</STRONG> (ARM, 148 bytes, Stack size 4 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff08a8]"></a>EStatusBar::GetStatusString(unsigned char)</STRONG> (ARM, 44 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff0860]"></a>EStatusBar::ClearLabelString()</STRONG> (ARM, 36 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff0818]"></a>EStatusBar::ClearStatusString(unsigned char)</STRONG> (ARM, 84 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[ff07d0]"></a>EStatusBar::SetStatusPosition(unsigned char, unsigned)</STRONG> (ARM, 28 bytes, Stack size 0 bytes, econtrol.o(.text), UNUSED)

<P><STRONG><a name="[fee780]"></a>ECursor::SetCursorPosition(const EPosition&)</STRONG> (ARM, 744 bytes, Stack size 48 bytes, ecursor.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ECursor::SetCursorPosition(const EPosition&)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb0e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetCursorEvent(const EPosition&, unsigned)
<LI><a href="#[feb128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetCursorEvent(EEvent*)
<LI><a href="#[10197c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::GlobalRedraw()
</UL>

<P><STRONG><a name="[febea8]"></a>EG_HookFunc_RedrawESimpleWindow(ESimpleWindow*)</STRONG> (ARM, 4 bytes, Stack size 0 bytes, eframe.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[feb908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawSelectedControls()
<LI><a href="#[feb950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::ForceRedrawAllControls()
<LI><a href="#[febb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::RedrawControl(const EPosition&)
<LI><a href="#[febbd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::RedrawSelectedControls()
<LI><a href="#[febc20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::ForceRedrawAllControls()
</UL>

<P><STRONG><a name="[febe60]"></a>EG_HookFunc_RedrawEWindow(ESimpleWindow*)</STRONG> (ARM, 4 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[febe18]"></a>EG_HookFunc_RedrawEDesktop(ESimpleDesktop*)</STRONG> (ARM, 4 bytes, Stack size 0 bytes, eframe.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[feb200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SelectedRedraw()
<LI><a href="#[10197c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::GlobalRedraw()
</UL>

<P><STRONG><a name="[febdd0]"></a>ESimpleWindow::ESimpleWindow()</STRONG> (ARM, 56 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[feba70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow()
</UL>

<P><STRONG><a name="[febd88]"></a>ESimpleWindow::ESimpleWindow__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[febd40]"></a>ESimpleWindow::ESimpleWindow(char*)</STRONG> (ARM, 56 bytes, Stack size 0 bytes, eframe.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1019588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow(char*, EPosition, ESize, bool)
</UL>

<P><STRONG><a name="[febcf8]"></a>ESimpleWindow::ESimpleWindow__sub_object(char*)</STRONG> (ARM, 0 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[febcb0]"></a>ESimpleWindow::RemoveAllControl()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[febc68]"></a>ESimpleWindow::RemoveLastControl()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[1019810]"></a>ESimpleWindow::RemoveControl(int)</STRONG> (ARM, 80 bytes, Stack size 4 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1019cd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nextButtonCBF(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[febc20]"></a>ESimpleWindow::ForceRedrawAllControls()</STRONG> (ARM, 60 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = ESimpleWindow::ForceRedrawAllControls() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[febea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawESimpleWindow(ESimpleWindow*)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV13ESimpleWindow)
</UL>
<P><STRONG><a name="[febbd8]"></a>ESimpleWindow::RedrawSelectedControls()</STRONG> (ARM, 80 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = ESimpleWindow::RedrawSelectedControls() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[febea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawESimpleWindow(ESimpleWindow*)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV13ESimpleWindow)
</UL>
<P><STRONG><a name="[febb90]"></a>ESimpleWindow::RedrawControl(const EPosition&)</STRONG> (ARM, 88 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[febea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawESimpleWindow(ESimpleWindow*)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[100d7e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::InControlArea(EPosition)
</UL>

<P><STRONG><a name="[febb48]"></a>ESimpleWindow::SelectControl(EPosition)</STRONG> (ARM, 80 bytes, Stack size 32 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = ESimpleWindow::SelectControl(EPosition) &rArr; EControl::InControlArea(EPosition)
</UL>
<BR>[Calls]<UL><LI><a href="#[100d7e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::InControlArea(EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
<LI><a href="#[febb00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[febb00]"></a>ESimpleWindow::DispatchEvent(EEvent*)</STRONG> (ARM, 60 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = ESimpleWindow::DispatchEvent(EEvent*) &rArr; ESimpleWindow::SelectControl(EPosition) &rArr; EControl::InControlArea(EPosition)
</UL>
<BR>[Calls]<UL><LI><a href="#[febb48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::SelectControl(EPosition)
<LI><a href="#[100d828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::NoticeControl(EEvent*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV13ESimpleWindow)
</UL>
<P><STRONG><a name="[febab8]"></a>EWindow::RemoveAllMenuItems()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, eframe.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[feba70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow()
<LI><a href="#[1019588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow(char*, EPosition, ESize, bool)
</UL>

<P><STRONG><a name="[feba70]"></a>EWindow::EWindow()</STRONG> (ARM, 176 bytes, Stack size 8 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[febab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RemoveAllMenuItems()
<LI><a href="#[febdd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::ESimpleWindow()
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[feba28]"></a>EWindow::EWindow__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[1019588]"></a>EWindow::EWindow(char*, EPosition, ESize, bool)</STRONG> (ARM, 188 bytes, Stack size 32 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EWindow::EWindow(char*, EPosition, ESize, bool)
</UL>
<BR>[Calls]<UL><LI><a href="#[febab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RemoveAllMenuItems()
<LI><a href="#[febd40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::ESimpleWindow(char*)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[feb9e0]"></a>EWindow::EWindow__sub_object(char*, EPosition, ESize, bool)</STRONG> (ARM, 0 bytes, Stack size 32 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[feb998]"></a>EWindow::RedrawBaseWindow()</STRONG> (ARM, 496 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = EWindow::RedrawBaseWindow() &rArr; EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::ForceRedrawAllControls()
</UL>

<P><STRONG><a name="[feb950]"></a>EWindow::ForceRedrawAllControls()</STRONG> (ARM, 176 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = EWindow::ForceRedrawAllControls() &rArr; EWindow::RedrawBaseWindow() &rArr; EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[febea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawESimpleWindow(ESimpleWindow*)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV7EWindow)
</UL>
<P><STRONG><a name="[feb908]"></a>EWindow::RedrawSelectedControls()</STRONG> (ARM, 164 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EWindow::RedrawSelectedControls() &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[febea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawESimpleWindow(ESimpleWindow*)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV7EWindow)
</UL>
<P><STRONG><a name="[feb8c0]"></a>EWindow::InTitleArea(EPosition)</STRONG> (ARM, 104 bytes, Stack size 12 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = EWindow::InTitleArea(EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb878]"></a>EWindow::MinimizeWindow()</STRONG> (ARM, 56 bytes, Stack size 8 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EWindow::MinimizeWindow()
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb830]"></a>EWindow::InMinArea(EPosition)</STRONG> (ARM, 124 bytes, Stack size 12 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = EWindow::InMinArea(EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb7e8]"></a>EWindow::AdjustBarPosition()</STRONG> (ARM, 840 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EWindow::AdjustBarPosition()
</UL>
<BR>[Calls]<UL><LI><a href="#[100d750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::AdjustControlPosition()
</UL>
<BR>[Called By]<UL><LI><a href="#[feb4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RecoverWindow()
<LI><a href="#[feb518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow()
<LI><a href="#[feb560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MoveWindow(EPosition)
<LI><a href="#[feb710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow(ESize)
<LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
</UL>

<P><STRONG><a name="[feb7a0]"></a>EWindow::AdjustMenuPosition()</STRONG> (ARM, 104 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EWindow::AdjustMenuPosition() &rArr; EWindow::AdjustBarPosition()
</UL>
<BR>[Calls]<UL><LI><a href="#[feb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustBarPosition()
</UL>
<BR>[Called By]<UL><LI><a href="#[feb440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RemoveMenuItem(unsigned)
<LI><a href="#[feb488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AddMenuItem(EMenu*)
<LI><a href="#[feb4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RecoverWindow()
<LI><a href="#[feb518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow()
<LI><a href="#[feb560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MoveWindow(EPosition)
<LI><a href="#[feb710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow(ESize)
</UL>

<P><STRONG><a name="[feb758]"></a>EWindow::AdjustControlPosition(int, int)</STRONG> (ARM, 92 bytes, Stack size 4 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = EWindow::AdjustControlPosition(int, int)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RecoverWindow()
<LI><a href="#[feb518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow()
<LI><a href="#[feb560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MoveWindow(EPosition)
<LI><a href="#[feb710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow(ESize)
</UL>

<P><STRONG><a name="[feb710]"></a>EWindow::MaximizeWindow(ESize)</STRONG> (ARM, 132 bytes, Stack size 32 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = EWindow::MaximizeWindow(ESize) &rArr; EWindow::AdjustMenuPosition() &rArr; EWindow::AdjustBarPosition()
</UL>
<BR>[Calls]<UL><LI><a href="#[feb758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustControlPosition(int, int)
<LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
<LI><a href="#[feb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustBarPosition()
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb6c8]"></a>EWindow::InMaxArea(EPosition)</STRONG> (ARM, 124 bytes, Stack size 12 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = EWindow::InMaxArea(EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb680]"></a>ESimpleDesktop::GetWindowIndex(ESimpleWindow*)</STRONG> (ARM, 64 bytes, Stack size 0 bytes, eframe.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb638]"></a>ESimpleDesktop::RemoveWindow(unsigned char)</STRONG> (ARM, 96 bytes, Stack size 4 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = ESimpleDesktop::RemoveWindow(unsigned char)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetWindowLayer(unsigned char, unsigned char)
<LI><a href="#[feb290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetWindowTopmost(unsigned char)
<LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb5f0]"></a>EWindow::InExitArea(EPosition)</STRONG> (ARM, 124 bytes, Stack size 12 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = EWindow::InExitArea(EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb5a8]"></a>EWindow::DispatchEvent(EEvent*)</STRONG> (ARM, 724 bytes, Stack size 40 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = EWindow::DispatchEvent(EEvent*) &rArr; EWindow::MaximizeWindow(ESize) &rArr; EWindow::AdjustMenuPosition() &rArr; EWindow::AdjustBarPosition()
</UL>
<BR>[Calls]<UL><LI><a href="#[feb5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::InExitArea(EPosition)
<LI><a href="#[feb638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::RemoveWindow(unsigned char)
<LI><a href="#[feb680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::GetWindowIndex(ESimpleWindow*)
<LI><a href="#[feb6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::InMaxArea(EPosition)
<LI><a href="#[feb710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MaximizeWindow(ESize)
<LI><a href="#[feb830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::InMinArea(EPosition)
<LI><a href="#[feb878]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::MinimizeWindow()
<LI><a href="#[feb8c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::InTitleArea(EPosition)
<LI><a href="#[febb48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::SelectControl(EPosition)
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[100c160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::ClosePopupMenu()
<LI><a href="#[100c1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::ShowPopupMenu(const EPosition&)
<LI><a href="#[100d7e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::InControlArea(EPosition)
<LI><a href="#[100d828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::NoticeControl(EEvent*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV7EWindow)
</UL>
<P><STRONG><a name="[feb560]"></a>EWindow::MoveWindow(EPosition)</STRONG> (ARM, 116 bytes, Stack size 32 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustControlPosition(int, int)
<LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
<LI><a href="#[feb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustBarPosition()
</UL>

<P><STRONG><a name="[feb518]"></a>EWindow::MaximizeWindow()</STRONG> (ARM, 136 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustControlPosition(int, int)
<LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
<LI><a href="#[feb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustBarPosition()
</UL>

<P><STRONG><a name="[feb4d0]"></a>EWindow::RecoverWindow()</STRONG> (ARM, 132 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = EWindow::RecoverWindow() &rArr; EWindow::AdjustMenuPosition() &rArr; EWindow::AdjustBarPosition()
</UL>
<BR>[Calls]<UL><LI><a href="#[feb758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustControlPosition(int, int)
<LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
<LI><a href="#[feb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustBarPosition()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV7EWindow)
</UL>
<P><STRONG><a name="[feb488]"></a>EWindow::AddMenuItem(EMenu*)</STRONG> (ARM, 68 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
</UL>

<P><STRONG><a name="[feb440]"></a>EWindow::RemoveMenuItem(unsigned)</STRONG> (ARM, 84 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::AdjustMenuPosition()
</UL>

<P><STRONG><a name="[feb3f8]"></a>EWindow::InWindowArea(EPosition)</STRONG> (ARM, 92 bytes, Stack size 12 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = EWindow::InWindowArea(EPosition)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV7EWindow)
</UL>
<P><STRONG><a name="[10196f0]"></a>ESimpleDesktop::ESimpleDesktop()</STRONG> (ARM, 176 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ESimpleDesktop::ESimpleDesktop()
</UL>
<BR>[Calls]<UL><LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::EDesktop()
<LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[feb3b0]"></a>ESimpleDesktop::ESimpleDesktop__sub_object()</STRONG> (ARM, 0 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[1019738]"></a>ESimpleDesktop::AddWindow(ESimpleWindow*)</STRONG> (ARM, 52 bytes, Stack size 0 bytes, eframe.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
<LI><a href="#[feb290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetWindowTopmost(unsigned char)
</UL>

<P><STRONG><a name="[feb368]"></a>ESimpleDesktop::AddWindow(ESimpleWindow*, unsigned char)</STRONG> (ARM, 104 bytes, Stack size 8 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[feb248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetWindowLayer(unsigned char, unsigned char)
</UL>

<P><STRONG><a name="[feb320]"></a>ESimpleDesktop::RemoveAllWindow()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[feb2d8]"></a>ESimpleDesktop::RemoveTopmostWindow()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[feb290]"></a>ESimpleDesktop::SetWindowTopmost(unsigned char)</STRONG> (ARM, 52 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ESimpleDesktop::SetWindowTopmost(unsigned char) &rArr; ESimpleDesktop::RemoveWindow(unsigned char)
</UL>
<BR>[Calls]<UL><LI><a href="#[feb638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::RemoveWindow(unsigned char)
<LI><a href="#[1019738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::AddWindow(ESimpleWindow*)
</UL>
<BR>[Called By]<UL><LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
</UL>

<P><STRONG><a name="[feb248]"></a>ESimpleDesktop::SetWindowLayer(unsigned char, unsigned char)</STRONG> (ARM, 60 bytes, Stack size 20 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::AddWindow(ESimpleWindow*, unsigned char)
<LI><a href="#[feb638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::RemoveWindow(unsigned char)
</UL>

<P><STRONG><a name="[10197c8]"></a>ESimpleDesktop::GlobalRedraw()</STRONG> (ARM, 128 bytes, Stack size 24 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ESimpleDesktop::GlobalRedraw() &rArr; ECursor::SetCursorPosition(const EPosition&)
</UL>
<BR>[Calls]<UL><LI><a href="#[feaa68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDFlushBuffer()
<LI><a href="#[febe18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawEDesktop(ESimpleDesktop*)
<LI><a href="#[fee780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECursor::SetCursorPosition(const EPosition&)
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
<LI><a href="#[1019780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::ScheduleRedraw()
</UL>

<P><STRONG><a name="[feb200]"></a>ESimpleDesktop::SelectedRedraw()</STRONG> (ARM, 128 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feaa68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDFlushBuffer()
<LI><a href="#[febe18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_HookFunc_RedrawEDesktop(ESimpleDesktop*)
</UL>
<BR>[Called By]<UL><LI><a href="#[1019780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::ScheduleRedraw()
</UL>

<P><STRONG><a name="[1019780]"></a>ESimpleDesktop::ScheduleRedraw()</STRONG> (ARM, 68 bytes, Stack size 8 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SelectedRedraw()
<LI><a href="#[10197c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::GlobalRedraw()
</UL>
<BR>[Called By]<UL><LI><a href="#[1019d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIRedraw
</UL>

<P><STRONG><a name="[feb1b8]"></a>ESimpleDesktop::DispatchEvent(EEvent*)</STRONG> (ARM, 140 bytes, Stack size 16 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ESimpleDesktop::DispatchEvent(EEvent*)
</UL>
<BR>[Called By]<UL><LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV14ESimpleDesktop)
</UL>
<P><STRONG><a name="[feb170]"></a>ESimpleDesktop::SetKeyboardEvent(const EPosition&, unsigned)</STRONG> (ARM, 80 bytes, Stack size 32 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feac18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEvent::EEvent()
</UL>

<P><STRONG><a name="[feb128]"></a>ESimpleDesktop::SetCursorEvent(EEvent*)</STRONG> (ARM, 60 bytes, Stack size 24 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fee780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECursor::SetCursorPosition(const EPosition&)
</UL>

<P><STRONG><a name="[feb0e0]"></a>ESimpleDesktop::SetCursorEvent(const EPosition&, unsigned)</STRONG> (ARM, 132 bytes, Stack size 40 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feac18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEvent::EEvent()
<LI><a href="#[fee780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECursor::SetCursorPosition(const EPosition&)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[feb098]"></a>EDesktop::RecalculateWindowTitleCount()</STRONG> (ARM, 88 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[feaea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::AppendClock(EClock*)
<LI><a href="#[feaee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::AppendStartMenu(EMenu*)
<LI><a href="#[feb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::EDesktop()
</UL>

<P><STRONG><a name="[feb050]"></a>EDesktop::RemoveAllIconButton()</STRONG> (ARM, 48 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[feb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::EDesktop()
</UL>

<P><STRONG><a name="[feb008]"></a>EDesktop::EDesktop()</STRONG> (ARM, 192 bytes, Stack size 8 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RemoveAllIconButton()
<LI><a href="#[feb098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RecalculateWindowTitleCount()
<LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[10196f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::ESimpleDesktop()
</UL>

<P><STRONG><a name="[feafc0]"></a>EDesktop::EDesktop__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[feaf78]"></a>EDesktop::AddIconButton(EIconButton*)</STRONG> (ARM, 56 bytes, Stack size 0 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[feaf30]"></a>EDesktop::RemoveIconButton(unsigned)</STRONG> (ARM, 68 bytes, Stack size 4 bytes, eframe.o(.text), UNUSED)

<P><STRONG><a name="[feaee8]"></a>EDesktop::AppendStartMenu(EMenu*)</STRONG> (ARM, 104 bytes, Stack size 40 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RecalculateWindowTitleCount()
<LI><a href="#[100c3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::CollapseMenu()
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>

<P><STRONG><a name="[feaea0]"></a>EDesktop::AppendClock(EClock*)</STRONG> (ARM, 64 bytes, Stack size 16 bytes, eframe.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[feb098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RecalculateWindowTitleCount()
</UL>

<P><STRONG><a name="[feae58]"></a>EDesktop::DispatchEvent(EEvent*)</STRONG> (ARM, 524 bytes, Stack size 24 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48 + Unknown Stack Size
<LI>Call Chain = EDesktop::DispatchEvent(EEvent*) &rArr; EPopupMenu::ShowPopupMenu(const EPosition&) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[feb1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::DispatchEvent(EEvent*)
<LI><a href="#[feb290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetWindowTopmost(unsigned char)
<LI><a href="#[100c160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::ClosePopupMenu()
<LI><a href="#[100c1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::ShowPopupMenu(const EPosition&)
<LI><a href="#[100d7e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::InControlArea(EPosition)
<LI><a href="#[100d828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::NoticeControl(EEvent*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV8EDesktop)
</UL>
<P><STRONG><a name="[feae10]"></a>EDesktop::RedrawDesktop()</STRONG> (ARM, 468 bytes, Stack size 40 bytes, eframe.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = EDesktop::RedrawDesktop() &rArr; EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff01a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawConstString(unsigned, unsigned, char*, unsigned char)
<LI><a href="#[ff02c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
<LI><a href="#[10198a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearBuffer()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV8EDesktop)
</UL>
<P><STRONG><a name="[ff0158]"></a>EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)</STRONG> (ARM, 56 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe8f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledEllipse(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[fe9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledCircle(unsigned, unsigned, unsigned)
<LI><a href="#[fe91d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWidthLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[ff0080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100d948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::DrawExtendIcon(const EPosition&, bool)
<LI><a href="#[100dd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEScroll(EControl*)
<LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
</UL>

<P><STRONG><a name="[ff0110]"></a>EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)</STRONG> (ARM, 56 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe91d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWidthLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[ff00c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100d948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::DrawExtendIcon(const EPosition&, bool)
<LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
</UL>

<P><STRONG><a name="[fe9268]"></a>EG_Graphic_DrawWhiteHorizonLine(unsigned, unsigned, unsigned)</STRONG> (ARM, 56 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EG_Graphic_DrawWhiteHorizonLine(unsigned, unsigned, unsigned) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe9100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledCircle(unsigned, unsigned, unsigned)
<LI><a href="#[ff0038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe9220]"></a>EG_Graphic_DrawWhiteVerticalLine(unsigned, unsigned, unsigned)</STRONG> (ARM, 56 bytes, Stack size 24 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearPixel(unsigned, unsigned)
</UL>

<P><STRONG><a name="[ff0308]"></a>EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)</STRONG> (ARM, 596 bytes, Stack size 72 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe9028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawPieSlice(unsigned, unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[feae10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RedrawDesktop()
<LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100dd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEScroll(EControl*)
<LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
</UL>

<P><STRONG><a name="[fe91d8]"></a>EG_Graphic_DrawWidthLine(unsigned, unsigned, unsigned, unsigned, unsigned char)</STRONG> (ARM, 788 bytes, Stack size 80 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>

<P><STRONG><a name="[ff00c8]"></a>EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 112 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = EG_Graphic_DrawEmptyRectangle(unsigned, unsigned, unsigned, unsigned) &rArr; EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[feae10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RedrawDesktop()
<LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100d6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEStatusBar(EControl*)
<LI><a href="#[100d708]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEToolBar(EControl*)
<LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100d948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::DrawExtendIcon(const EPosition&, bool)
<LI><a href="#[100daf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEPopupMenu(EControl*)
<LI><a href="#[100db88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMenu(EControl*)
<LI><a href="#[100dca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEList(EControl*)
<LI><a href="#[100dd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEScroll(EControl*)
<LI><a href="#[100ddc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEDialogBox(EControl*)
<LI><a href="#[100dea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMessageBox(EControl*)
<LI><a href="#[100df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEIconButton(EControl*)
<LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
<LI><a href="#[100e1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEProgress(EControl*)
<LI><a href="#[100e200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEEdit(EControl*)
<LI><a href="#[100e290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultECheckButton(EControl*)
<LI><a href="#[100e320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEButton(EControl*)
</UL>

<P><STRONG><a name="[ff0080]"></a>EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 64 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = EG_Graphic_DrawFilledRectangle(unsigned, unsigned, unsigned, unsigned) &rArr; EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned) &rArr; EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100daf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEPopupMenu(EControl*)
<LI><a href="#[100db88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMenu(EControl*)
<LI><a href="#[100dd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEScroll(EControl*)
<LI><a href="#[100ddc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEDialogBox(EControl*)
<LI><a href="#[100dea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMessageBox(EControl*)
<LI><a href="#[100e1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEProgress(EControl*)
<LI><a href="#[100e290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultECheckButton(EControl*)
</UL>

<P><STRONG><a name="[ff0038]"></a>EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 64 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = EG_Graphic_DrawWhiteFilledRectangle(unsigned, unsigned, unsigned, unsigned) &rArr; EG_Graphic_DrawWhiteHorizonLine(unsigned, unsigned, unsigned) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe9268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteHorizonLine(unsigned, unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100daf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEPopupMenu(EControl*)
<LI><a href="#[100db88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMenu(EControl*)
<LI><a href="#[100dca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEList(EControl*)
<LI><a href="#[100dd38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEScroll(EControl*)
<LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
<LI><a href="#[100e290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultECheckButton(EControl*)
</UL>

<P><STRONG><a name="[fe9190]"></a>EG_Graphic_DrawEmptyCircle(unsigned, unsigned, unsigned)</STRONG> (ARM, 768 bytes, Stack size 96 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe9148]"></a>EG_Graphic_DrawFilledCircle(unsigned, unsigned, unsigned)</STRONG> (ARM, 1292 bytes, Stack size 104 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe9100]"></a>EG_Graphic_DrawWhiteFilledCircle(unsigned, unsigned, unsigned)</STRONG> (ARM, 1292 bytes, Stack size 104 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearPixel(unsigned, unsigned)
<LI><a href="#[fe9268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteHorizonLine(unsigned, unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe90b8]"></a>EG_Graphic_DrawQuarterArc(unsigned, unsigned, unsigned, unsigned char)</STRONG> (ARM, 960 bytes, Stack size 56 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe9070]"></a>EG_Graphic_DrawArc(unsigned, unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 2108 bytes, Stack size 56 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe9028]"></a>EG_Graphic_DrawPieSlice(unsigned, unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 2340 bytes, Stack size 56 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
<LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
</UL>

<P><STRONG><a name="[fe8fe0]"></a>EG_Graphic_DrawEmptyEllipse(unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 868 bytes, Stack size 112 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>

<P><STRONG><a name="[fe8f98]"></a>EG_Graphic_DrawFilledEllipse(unsigned, unsigned, unsigned, unsigned)</STRONG> (ARM, 1056 bytes, Stack size 96 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
</UL>

<P><STRONG><a name="[ff0350]"></a>EG_Graphic_DrawChar(unsigned, unsigned, char)</STRONG> (ARM, 96 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetByte(unsigned, unsigned, unsigned char)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff01a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawConstString(unsigned, unsigned, char*, unsigned char)
<LI><a href="#[ff0230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawString(unsigned, unsigned, char*)
<LI><a href="#[ff0278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNumber(unsigned, unsigned, int)
<LI><a href="#[100d5a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEClock(EControl*)
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100e200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEEdit(EControl*)
</UL>

<P><STRONG><a name="[fe8f50]"></a>EG_Graphic_DrawNotChar(unsigned, unsigned, char)</STRONG> (ARM, 104 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = EG_Graphic_DrawNotChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetByte(unsigned, unsigned, unsigned char)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff01e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotString(unsigned, unsigned, char*)
</UL>

<P><STRONG><a name="[ff0230]"></a>EG_Graphic_DrawString(unsigned, unsigned, char*)</STRONG> (ARM, 68 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = EG_Graphic_DrawString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb998]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawBaseWindow()
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
<LI><a href="#[100d6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEStatusBar(EControl*)
<LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100daf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEPopupMenu(EControl*)
<LI><a href="#[100db88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMenu(EControl*)
<LI><a href="#[100dca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEList(EControl*)
<LI><a href="#[100ddc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEDialogBox(EControl*)
<LI><a href="#[100dea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMessageBox(EControl*)
<LI><a href="#[100df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEIconButton(EControl*)
<LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
<LI><a href="#[100e0e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEExtLabel(EControl*)
<LI><a href="#[100e290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultECheckButton(EControl*)
<LI><a href="#[100e320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEButton(EControl*)
<LI><a href="#[100e368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultELabel(EControl*)
</UL>

<P><STRONG><a name="[ff01e8]"></a>EG_Graphic_DrawNotString(unsigned, unsigned, char*)</STRONG> (ARM, 68 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = EG_Graphic_DrawNotString(unsigned, unsigned, char*) &rArr; EG_Graphic_DrawNotChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotChar(unsigned, unsigned, char)
</UL>
<BR>[Called By]<UL><LI><a href="#[100daf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEPopupMenu(EControl*)
<LI><a href="#[100db88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMenu(EControl*)
<LI><a href="#[100ddc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEDialogBox(EControl*)
<LI><a href="#[100dea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEMessageBox(EControl*)
<LI><a href="#[100e0e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEExtLabel(EControl*)
</UL>

<P><STRONG><a name="[ff01a0]"></a>EG_Graphic_DrawConstString(unsigned, unsigned, char*, unsigned char)</STRONG> (ARM, 88 bytes, Stack size 24 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = EG_Graphic_DrawConstString(unsigned, unsigned, char*, unsigned char) &rArr; EG_Graphic_DrawChar(unsigned, unsigned, char) &rArr; EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
</UL>
<BR>[Called By]<UL><LI><a href="#[feae10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RedrawDesktop()
<LI><a href="#[100e200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEEdit(EControl*)
</UL>

<P><STRONG><a name="[ff0278]"></a>EG_Graphic_DrawNumber(unsigned, unsigned, int)</STRONG> (ARM, 380 bytes, Stack size 32 bytes, graphicfunc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe64a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod
<LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
</UL>
<BR>[Called By]<UL><LI><a href="#[100d5a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEClock(EControl*)
<LI><a href="#[100d5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEBarChart(EControl*)
</UL>

<P><STRONG><a name="[ff02c0]"></a>EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*)</STRONG> (ARM, 172 bytes, Stack size 40 bytes, graphicfunc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearPixel(unsigned, unsigned)
<LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[feae10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RedrawDesktop()
<LI><a href="#[100df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEIconButton(EControl*)
<LI><a href="#[100dfc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEIcon(EControl*)
</UL>

<P><STRONG><a name="[fe84a0]"></a>EG_LCDDelay(unsigned)</STRONG> (ARM, 52 bytes, Stack size 0 bytes, lcddriver.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe8458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDReset()
</UL>

<P><STRONG><a name="[fe8458]"></a>EG_LCDReset()</STRONG> (ARM, 104 bytes, Stack size 4 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = EG_LCDReset()
</UL>
<BR>[Calls]<UL><LI><a href="#[fe84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDDelay(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[10198e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDInit()
</UL>

<P><STRONG><a name="[fe8410]"></a>EG_LCDCheckBusy()</STRONG> (ARM, 28 bytes, Stack size 0 bytes, lcddriver.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe8338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteData(unsigned char)
<LI><a href="#[fe8380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDReadData(unsigned char)
</UL>

<P><STRONG><a name="[fe83c8]"></a>EG_LCDWriteCommand(unsigned char, unsigned char)</STRONG> (ARM, 236 bytes, Stack size 0 bytes, lcddriver.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe82a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearScreen()
<LI><a href="#[fe82f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDShowByte(unsigned char, unsigned, unsigned)
<LI><a href="#[feaa68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDFlushBuffer()
<LI><a href="#[10198e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDInit()
</UL>

<P><STRONG><a name="[fe8380]"></a>EG_LCDReadData(unsigned char)</STRONG> (ARM, 280 bytes, Stack size 4 bytes, lcddriver.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8410]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDCheckBusy()
</UL>

<P><STRONG><a name="[fe8338]"></a>EG_LCDWriteData(unsigned char)</STRONG> (ARM, 144 bytes, Stack size 4 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = EG_LCDWriteData(unsigned char)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8410]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDCheckBusy()
</UL>
<BR>[Called By]<UL><LI><a href="#[fe82a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearScreen()
<LI><a href="#[fe82f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDShowByte(unsigned char, unsigned, unsigned)
<LI><a href="#[feaa68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDFlushBuffer()
</UL>

<P><STRONG><a name="[fe82f0]"></a>EG_LCDShowByte(unsigned char, unsigned, unsigned)</STRONG> (ARM, 56 bytes, Stack size 16 bytes, lcddriver.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteData(unsigned char)
<LI><a href="#[fe83c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteCommand(unsigned char, unsigned char)
</UL>

<P><STRONG><a name="[10198e8]"></a>EG_LCDInit()</STRONG> (ARM, 236 bytes, Stack size 4 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EG_LCDInit() &rArr; EG_LCDReset()
</UL>
<BR>[Calls]<UL><LI><a href="#[fe83c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteCommand(unsigned char, unsigned char)
<LI><a href="#[fe8458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDReset()
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
</UL>

<P><STRONG><a name="[fe82a8]"></a>EG_LCDClearScreen()</STRONG> (ARM, 92 bytes, Stack size 12 bytes, lcddriver.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe8338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteData(unsigned char)
<LI><a href="#[fe83c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteCommand(unsigned char, unsigned char)
</UL>

<P><STRONG><a name="[feaa68]"></a>EG_LCDFlushBuffer()</STRONG> (ARM, 100 bytes, Stack size 12 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EG_LCDFlushBuffer() &rArr; EG_LCDWriteData(unsigned char)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteData(unsigned char)
<LI><a href="#[fe83c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDWriteCommand(unsigned char, unsigned char)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SelectedRedraw()
<LI><a href="#[10197c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::GlobalRedraw()
</UL>

<P><STRONG><a name="[10198a0]"></a>EG_LCDClearBuffer()</STRONG> (ARM, 60 bytes, Stack size 0 bytes, lcddriver.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
<LI><a href="#[feacf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::RedrawDesktop()
<LI><a href="#[feae10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RedrawDesktop()
</UL>

<P><STRONG><a name="[fe8ec0]"></a>EG_LCDSetPixel(unsigned, unsigned)</STRONG> (ARM, 80 bytes, Stack size 8 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe8f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetByte(unsigned, unsigned, unsigned char)
<LI><a href="#[fe8f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledEllipse(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[fe8fe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyEllipse(unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[fe9028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawPieSlice(unsigned, unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[fe9070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawArc(unsigned, unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[fe90b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawQuarterArc(unsigned, unsigned, unsigned, unsigned char)
<LI><a href="#[fe9148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawFilledCircle(unsigned, unsigned, unsigned)
<LI><a href="#[fe9190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawEmptyCircle(unsigned, unsigned, unsigned)
<LI><a href="#[ff0110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff0158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff02c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*)
<LI><a href="#[ff0308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawLine(unsigned, unsigned, unsigned, unsigned, unsigned char)
</UL>

<P><STRONG><a name="[fe8e78]"></a>EG_LCDClearPixel(unsigned, unsigned)</STRONG> (ARM, 84 bytes, Stack size 8 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe8f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetByte(unsigned, unsigned, unsigned char)
<LI><a href="#[fe9100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteFilledCircle(unsigned, unsigned, unsigned)
<LI><a href="#[fe9220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteVerticalLine(unsigned, unsigned, unsigned)
<LI><a href="#[fe9268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawWhiteHorizonLine(unsigned, unsigned, unsigned)
<LI><a href="#[ff02c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawBitmap(unsigned, unsigned, EBitmap*)
</UL>

<P><STRONG><a name="[fe8260]"></a>EG_LCDGetPixel(unsigned, unsigned)</STRONG> (ARM, 76 bytes, Stack size 4 bytes, lcddriver.o(.text), UNUSED)

<P><STRONG><a name="[fe8218]"></a>EG_LCDGetHorizonalByte(unsigned, unsigned)</STRONG> (ARM, 284 bytes, Stack size 12 bytes, lcddriver.o(.text), UNUSED)

<P><STRONG><a name="[fe81d0]"></a>EG_LCDSetVerticalByte(unsigned, unsigned, unsigned char)</STRONG> (ARM, 88 bytes, Stack size 12 bytes, lcddriver.o(.text), UNUSED)

<P><STRONG><a name="[fe8188]"></a>EG_LCDSetORVerticalByte(unsigned, unsigned, unsigned char)</STRONG> (ARM, 124 bytes, Stack size 16 bytes, lcddriver.o(.text), UNUSED)

<P><STRONG><a name="[fe8140]"></a>EG_LCDSetANDVerticalByte(unsigned, unsigned, unsigned char)</STRONG> (ARM, 124 bytes, Stack size 16 bytes, lcddriver.o(.text), UNUSED)

<P><STRONG><a name="[fe8f08]"></a>EG_LCDSetByte(unsigned, unsigned, unsigned char)</STRONG> (ARM, 92 bytes, Stack size 24 bytes, lcddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = EG_LCDSetByte(unsigned, unsigned, unsigned char) &rArr; EG_LCDClearPixel(unsigned, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[fe8e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearPixel(unsigned, unsigned)
<LI><a href="#[fe8ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDSetPixel(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe8f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNotChar(unsigned, unsigned, char)
<LI><a href="#[ff0350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawChar(unsigned, unsigned, char)
</UL>

<P><STRONG><a name="[fe6cd0]"></a>__aeabi_memset</STRONG> (ARM, 16 bytes, Stack size 0 bytes, aeabi_memset.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[11eda90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[bb7100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAllocateTCBAndStack
</UL>

<P><STRONG><a name="[fe6b20]"></a>__aeabi_memcpy</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memcpy.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb9028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataFromQueue
<LI><a href="#[bb90b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataToQueue
</UL>

<P><STRONG><a name="[fe6ad8]"></a>__rt_memcpy</STRONG> (ARM, 212 bytes, Stack size 0 bytes, rt_memcpy.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11ed8d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[fe6a90]"></a>_memcpy_lastbytes</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy.o(.text), UNUSED)

<P><STRONG><a name="[fe6890]"></a>strncpy</STRONG> (ARM, 108 bytes, Stack size 8 bytes, strncpy.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[11edb20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[bb7148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTCBVariables
</UL>

<P><STRONG><a name="[fe64f0]"></a>__aeabi_idiv</STRONG> (ARM, 0 bytes, Stack size 8 bytes, aeabi_sdiv.o(.text), UNUSED)

<P><STRONG><a name="[fe64a8]"></a>__aeabi_idivmod</STRONG> (ARM, 384 bytes, Stack size 8 bytes, aeabi_sdiv.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[ff0278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawNumber(unsigned, unsigned, int)
</UL>

<P><STRONG><a name="[fe57b0]"></a>__use_two_region_memory</STRONG> (ARM, 4 bytes, Stack size 0 bytes, stkheap2.o(.text), UNUSED)

<P><STRONG><a name="[fe5768]"></a>__rt_stackheap_init</STRONG> (ARM, 36 bytes, Stack size 16 bytes, stkheap2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = __rt_stackheap_init &rArr; __user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[11f0858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_storage
<LI><a href="#[11f0fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>
<BR>[Called By]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[fe5720]"></a>__rt_heap_extend</STRONG> (ARM, 24 bytes, Stack size 8 bytes, stkheap2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_heap_extend
</UL>
<BR>[Calls]<UL><LI><a href="#[fe5648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_heap_extend (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11e80c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__heap_extend
</UL>

<P><STRONG><a name="[fe4f98]"></a>__cpp_initialize__aeabi_</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, init_aeabi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = __cpp_initialize__aeabi_
</UL>
<BR>[Calls]<UL><LI><a href="#[11ecd88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[fe0f50]"></a>__rt_entry</STRONG> (ARM, 76 bytes, Stack size 16 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + Unknown Stack Size
<LI>Call Chain = __rt_entry &rArr; __rt_lib_init &rArr; _init_alloc &rArr; __rt_SIGRTMEM &rArr; __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[fe5768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
<LI><a href="#[11e9330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_lib_init
<LI><a href="#[11e94a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_stackheap_init
<LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
<LI><a href="#[11ea4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit (via BX)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe54e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
<LI><a href="#[11e4d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
</UL>

<P><STRONG><a name="[fe0f08]"></a>__rt_exit</STRONG> (ARM, 20 bytes, Stack size 8 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = __rt_exit &rArr; __rt_lib_shutdown &rArr; __cxa_finalize &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11e9d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11ea4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit (via Veneer)
</UL>

<P><STRONG><a name="[fe0ec0]"></a>__rt_abort</STRONG> (ARM, 8 bytes, Stack size 0 bytes, kernel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11ec8c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>

<P><STRONG><a name="[11f0fe8]"></a>__user_setup_stackheap</STRONG> (ARM, 96 bytes, Stack size 8 bytes, sys_stackheap_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[bc3370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_initial_stackheap
<LI><a href="#[11ec5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[fe5768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[11f0858]"></a>__rt_stackheap_storage</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_stackheap_storage_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe5768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[11f04a0]"></a>__rt_ddtor_pointer_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_ddtor_pointer_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe4bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit (via Veneer)
<LI><a href="#[11ed418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize (via Veneer)
</UL>

<P><STRONG><a name="[11f0020]"></a>malloc</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, h1_alloc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = malloc &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11ebcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Full
<LI><a href="#[11ebef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe4bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit
</UL>

<P><STRONG><a name="[11edb20]"></a>__aeabi_memclr</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe6890]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>

<P><STRONG><a name="[11edad8]"></a>__rt_memclr</STRONG> (ARM, 64 bytes, Stack size 0 bytes, rt_memclr.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11ea240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[11eda90]"></a>_memset</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe6cd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>

<P><STRONG><a name="[11ed8d8]"></a>__aeabi_memcpy4</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[fe6ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memcpy
</UL>

<P><STRONG><a name="[11ed890]"></a>__aeabi_memcpy8</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11ed848]"></a>__rt_memcpy_w</STRONG> (ARM, 100 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11ed800]"></a>_memcpy_lastbytes_aligned</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11ecd88]"></a>__ARM_call_via_r0</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe4f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cpp_initialize__aeabi_
</UL>

<P><STRONG><a name="[11ecd40]"></a>__call_via_r0</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11eccf8]"></a>__ARM_call_via_r1</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11ed418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize
</UL>

<P><STRONG><a name="[11eccb0]"></a>__call_via_r1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecc68]"></a>__ARM_call_via_r2</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecc20]"></a>__call_via_r2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecbd8]"></a>__ARM_call_via_r3</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecb90]"></a>__call_via_r3</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecb48]"></a>__ARM_call_via_r4</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecb00]"></a>__call_via_r4</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ecab8]"></a>__ARM_call_via_r5</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11eca70]"></a>__call_via_r5</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11eca28]"></a>__ARM_call_via_r6</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ec9e0]"></a>__call_via_r6</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ec998]"></a>__ARM_call_via_r7</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ec950]"></a>__call_via_r7</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11ec8c0]"></a>_sys_exit</STRONG> (ARM, 20 bytes, Stack size 0 bytes, sys_exit.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe0ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_abort
<LI><a href="#[11e6590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sig_exit (via Veneer)
</UL>

<P><STRONG><a name="[11ec630]"></a>__user_libspace</STRONG> (ARM, 8 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[11ec5e8]"></a>__user_perproc_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11f0fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[11ec5a0]"></a>__user_perthread_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[11ebef8]"></a>__rt_heap_descriptor</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_heap_descriptor_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11eb140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free (via Veneer)
<LI><a href="#[11ebc68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc (via Veneer)
<LI><a href="#[11f0020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc (via Veneer)
</UL>

<P><STRONG><a name="[11ebd88]"></a>_terminate_user_alloc</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, init_alloc.o(.text), UNUSED)

<P><STRONG><a name="[11ebd40]"></a>_init_user_alloc</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, init_alloc.o(.text), UNUSED)

<P><STRONG><a name="[11ebcf8]"></a>__Heap_Full</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, init_alloc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __Heap_Full &rArr; __Heap_ProvideMemory &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11e80c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__heap_extend (via Veneer)
<LI><a href="#[11e8ad0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_ProvideMemory
</UL>
<BR>[Called By]<UL><LI><a href="#[11f0020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>

<P><STRONG><a name="[11ebcb0]"></a>__Heap_Broken</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, init_alloc.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11e83e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
</UL>

<P><STRONG><a name="[11ebc68]"></a>_init_alloc</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, init_alloc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = _init_alloc &rArr; __rt_SIGRTMEM &rArr; __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[11e80c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__heap_extend (via Veneer)
<LI><a href="#[11e83e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
<LI><a href="#[11e8ad0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_ProvideMemory
<LI><a href="#[11eb2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Initialize
<LI><a href="#[11ebef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[11eb708]"></a>__use_no_heap</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, hguard.o(.text), UNUSED)

<P><STRONG><a name="[11eb6c0]"></a>__heap_guard</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, hguard.o(.text), UNUSED)

<P><STRONG><a name="[11eb2f8]"></a>__Heap_Initialize</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, h1_init.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11ebc68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
</UL>

<P><STRONG><a name="[11eb2b0]"></a>__Heap_DescSize</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, h1_init.o(.text), UNUSED)

<P><STRONG><a name="[11eb140]"></a>free</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, h1_free.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = free
</UL>
<BR>[Calls]<UL><LI><a href="#[11ebef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11e8ad0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_ProvideMemory
<LI><a href="#[11ed418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize
</UL>

<P><STRONG><a name="[11ea4c8]"></a>exit</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = exit &rArr; __rt_exit &rArr; __rt_lib_shutdown &rArr; __cxa_finalize &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[fe0f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
<LI><a href="#[11ea438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_call_atexit_fns (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11ea318]"></a>__aeabi_memclr4</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[11ea2d0]"></a>__aeabi_memclr8</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[11ea288]"></a>__rt_memclr_w</STRONG> (ARM, 84 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[11ea240]"></a>_memset_w</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11edad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memclr
</UL>

<P><STRONG><a name="[11e9d98]"></a>__rt_lib_init</STRONG> (Thumb, 184 bytes, Stack size 40 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init &rArr; _init_alloc &rArr; __rt_SIGRTMEM &rArr; __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[fe4f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cpp_initialize__aeabi_
<LI><a href="#[11e7928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init (via Veneer)
<LI><a href="#[11e8c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[11e9888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_signal_init (Weak Reference)
<LI><a href="#[11e98d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_rand_init (Weak Reference)
<LI><a href="#[11e9918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio (Weak Reference)
<LI><a href="#[11e99a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_getenv_init (Weak Reference)
<LI><a href="#[11e99f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_time (Weak Reference)
<LI><a href="#[11e9a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (Weak Reference)
<LI><a href="#[11e9a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_monetary (Weak Reference)
<LI><a href="#[11e9ac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (Weak Reference)
<LI><a href="#[11e9b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_collate (Weak Reference)
<LI><a href="#[11e9b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_trap_init (Weak Reference)
<LI><a href="#[11e9ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_clock_init (Weak Reference)
<LI><a href="#[11e9be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_atexit_init (Weak Reference)
<LI><a href="#[11e9c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__alloca_initialize (Weak Reference)
<LI><a href="#[11e9c78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_exceptions_init (Weak Reference)
<LI><a href="#[11e9e28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_argv_veneer (via Veneer)
<LI><a href="#[11ebc68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry (via Veneer)
</UL>

<P><STRONG><a name="[11e9d50]"></a>__rt_lib_shutdown</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48 + Unknown Stack Size
<LI>Call Chain = __rt_lib_shutdown &rArr; __cxa_finalize &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11e97f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio (Weak Reference)
<LI><a href="#[11ed418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize
</UL>
<BR>[Called By]<UL><LI><a href="#[fe0f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
</UL>

<P><STRONG><a name="[11e94a0]"></a>_platform_post_stackheap_init</STRONG> (ARM, 12 bytes, Stack size 0 bytes, boardinit2.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11e9330]"></a>_platform_post_lib_init</STRONG> (ARM, 16 bytes, Stack size 8 bytes, boardinit3.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _platform_post_lib_init
</UL>
<BR>[Called By]<UL><LI><a href="#[fe0f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11e8ff8]"></a>__I_use_semihosting</STRONG> (ARM, 0 bytes, Stack size 0 bytes, use_no_semi.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> sys_exit.o(.text)
</UL>
<P><STRONG><a name="[11e8fb0]"></a>__use_no_semihosting_swi</STRONG> (ARM, 4 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[11e8c40]"></a>__rt_locale</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_locale_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[11e8ad0]"></a>__Heap_ProvideMemory</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, h1_extend.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __Heap_ProvideMemory &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11eb140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[11ebc68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
<LI><a href="#[11ebcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Full
</UL>

<P><STRONG><a name="[11e83e8]"></a>__rt_SIGRTMEM</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, defsig_rtmem_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __rt_SIGRTMEM &rArr; __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[11e6268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM_inner
<LI><a href="#[11e6590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sig_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[11ebc68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
<LI><a href="#[11ebcb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Broken
</UL>

<P><STRONG><a name="[11e80c0]"></a>__heap_extend</STRONG> (ARM, 16 bytes, Stack size 8 bytes, heapext.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __heap_extend &rArr; __rt_heap_extend
</UL>
<BR>[Calls]<UL><LI><a href="#[fe5720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_extend
</UL>
<BR>[Called By]<UL><LI><a href="#[11ebc68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc (via Veneer)
<LI><a href="#[11ebcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Full (via Veneer)
</UL>

<P><STRONG><a name="[11e7b00]"></a>__ARM_get_argv</STRONG> (Thumb, 6 bytes, Stack size 4 bytes, no_argv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __ARM_get_argv
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lib_init.o(.emb_text)
</UL>
<P><STRONG><a name="[11e71d8]"></a>__rt_fp_status_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_fp_status_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11e7928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[11e6590]"></a>__sig_exit</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, defsig_exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __sig_exit
</UL>
<BR>[Calls]<UL><LI><a href="#[11ec8c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11e83e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
</UL>

<P><STRONG><a name="[11e6268]"></a>__rt_SIGRTMEM_inner</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, defsig_rtmem_inner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[11e5e58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__default_signal_display
</UL>
<BR>[Called By]<UL><LI><a href="#[11e83e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
</UL>

<P><STRONG><a name="[11e5e58]"></a>__default_signal_display</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, defsig_general.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[11e5128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ttywrch
</UL>
<BR>[Called By]<UL><LI><a href="#[11e6268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM_inner
</UL>

<P><STRONG><a name="[11e5128]"></a>_ttywrch</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, sys_wrch.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _ttywrch
</UL>
<BR>[Called By]<UL><LI><a href="#[11e5e58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__default_signal_display
</UL>

<P><STRONG><a name="[fe6460]"></a>__aeabi_uidiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv), UNUSED)

<P><STRONG><a name="[fe6418]"></a>__aeabi_uidivmod</STRONG> (ARM, 28 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv))
<BR><BR>[Calls]<UL><LI><a href="#[fe6538]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div_large
<LI><a href="#[fe6580]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div4
<LI><a href="#[fe65c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div8
</UL>
<BR>[Called By]<UL><LI><a href="#[bbfc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xSerialPortInitMinimal
<LI><a href="#[fe9028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawPieSlice(unsigned, unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[fe9070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_Graphic_DrawArc(unsigned, unsigned, unsigned, unsigned, unsigned)
<LI><a href="#[feae58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::DispatchEvent(EEvent*)
<LI><a href="#[feb098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RecalculateWindowTitleCount()
<LI><a href="#[100d990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultETree(EControl*, EEvent*)
<LI><a href="#[100db40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEPopupMenu(EControl*, EEvent*)
<LI><a href="#[100dbd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*)
<LI><a href="#[100dcf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEList(EControl*, EEvent*)
<LI><a href="#[100e050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[bb5db8]"></a>vPortStartFirstTask</STRONG> (ARM, 0 bytes, Stack size unknown bytes, portasm.o(PORT_ASM))
<BR><BR>[Called By]<UL><LI><a href="#[bb6260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
</UL>

<P><STRONG><a name="[bb8608]"></a>vPortYield</STRONG> (ARM, 0 bytes, Stack size unknown bytes, portasm.o(PORT_ASM))
<BR><BR>[Called By]<UL><LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
<LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[bb6578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPrioritySet
<LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bb66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelete
<LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
<LI><a href="#[bb7028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[1010aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSemaphoreTest
</UL>

<P><STRONG><a name="[bc3250]"></a>vPortYieldProcessor</STRONG> (ARM, 0 bytes, Stack size unknown bytes, portasm.o(PORT_ASM))
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[bb5d70]"></a>vPreemptiveTick</STRONG> (ARM, 0 bytes, Stack size unknown bytes, portasm.o(PORT_ASM))
<BR>[Address Reference Count : 1]<UL><LI> port.o(.text)
</UL>
<P><STRONG><a name="[1019c90]"></a>ECheckButton::~ECheckButton()</STRONG> (ARM, 8 bytes, Stack size 0 bytes, guidemo.o(i._ZN12ECheckButtonD1Ev))
<BR>[Address Reference Count : 1]<UL><LI> guidemo.o(.text)
</UL>
<P><STRONG><a name="[1019c48]"></a>ECheckButton::~ECheckButton__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, guidemo.o(i._ZN12ECheckButtonD1Ev), UNUSED)

<P><STRONG><a name="[1019c00]"></a>ESimpleWindow::AddControl(EControl*)</STRONG> (ARM, 32 bytes, Stack size 0 bytes, guidemo.o(i._ZN13ESimpleWindow10AddControlEP8EControl))
<BR><BR>[Called By]<UL><LI><a href="#[bbfe58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vGUIInit
<LI><a href="#[1019cd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nextButtonCBF(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[feadc8]"></a>ESimpleWindow::InWindowArea(EPosition)</STRONG> (ARM, 20 bytes, Stack size 12 bytes, eframe.o(i._ZN13ESimpleWindow12InWindowAreaE9EPosition))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ESimpleWindow::InWindowArea(EPosition)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV13ESimpleWindow)
</UL>
<P><STRONG><a name="[fead80]"></a>ESimpleWindow::RecoverWindow()</STRONG> (ARM, 4 bytes, Stack size 0 bytes, eframe.o(i._ZN13ESimpleWindow13RecoverWindowEv))
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV13ESimpleWindow)
</UL>
<P><STRONG><a name="[fead38]"></a>ESimpleWindow::GetWindowState()</STRONG> (ARM, 12 bytes, Stack size 0 bytes, eframe.o(i._ZN13ESimpleWindow14GetWindowStateEv))
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV13ESimpleWindow)
</UL>
<P><STRONG><a name="[feacf0]"></a>ESimpleDesktop::RedrawDesktop()</STRONG> (ARM, 20 bytes, Stack size 8 bytes, eframe.o(i._ZN14ESimpleDesktop13RedrawDesktopEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = ESimpleDesktop::RedrawDesktop()
</UL>
<BR>[Calls]<UL><LI><a href="#[10198a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_LCDClearBuffer()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV14ESimpleDesktop)
</UL>
<P><STRONG><a name="[1019bb8]"></a>EEdit::~EEdit()</STRONG> (ARM, 8 bytes, Stack size 0 bytes, guidemo.o(i._ZN5EEditD1Ev))
<BR>[Address Reference Count : 1]<UL><LI> guidemo.o(.text)
</UL>
<P><STRONG><a name="[1019b70]"></a>EEdit::~EEdit__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, guidemo.o(i._ZN5EEditD1Ev), UNUSED)

<P><STRONG><a name="[ff0788]"></a>EMenu::SetSelectItem(unsigned)</STRONG> (ARM, 28 bytes, Stack size 0 bytes, econtrol.o(i._ZN5EMenu13SetSelectItemEj))
<BR><BR>[Called By]<UL><LI><a href="#[100dbd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[ff0740]"></a>ESize::ESize(unsigned, unsigned)</STRONG> (ARM, 12 bytes, Stack size 0 bytes, econtrol.o(i._ZN5ESizeC1Ejj))
<BR><BR>[Called By]<UL><LI><a href="#[feb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::EDesktop()
<LI><a href="#[feb5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::DispatchEvent(EEvent*)
<LI><a href="#[feba70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow()
<LI><a href="#[ff0590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))
<LI><a href="#[100bc08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::EToolBar(EPosition)
<LI><a href="#[100c3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::EPopupMenu()
<LI><a href="#[100c5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::EMenu(char*, unsigned, EPosition, bool)
<LI><a href="#[100c670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::EMenu()
<LI><a href="#[100c940]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EScroll::EScroll(EPosition, unsigned, unsigned)
<LI><a href="#[100ca60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDialogBox::EDialogBox(unsigned char, EPosition, char*, unsigned)
<LI><a href="#[100cb38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMessageBox::EMessageBox(unsigned char, EPosition, char*, unsigned)
<LI><a href="#[100cd78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIcon::EIcon(void(*)(EControl*, EEvent*), EPosition, unsigned)
<LI><a href="#[100cf28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::EComboBox(EPosition, unsigned)
<LI><a href="#[100d240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(void(*)(EControl*, EEvent*), char*, bool, EPosition, unsigned)
<LI><a href="#[100d2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(char*, bool, EPosition, unsigned)
<LI><a href="#[100d3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECheckButton::ECheckButton(void(*)(EControl*, EEvent*), bool, EPosition, char*, unsigned)
<LI><a href="#[100d510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)
<LI><a href="#[1019588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow(char*, EPosition, ESize, bool)
<LI><a href="#[10195d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EButton::EButton(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)
<LI><a href="#[1019618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(EPosition, char*, unsigned)
<LI><a href="#[1019660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(bool, EPosition, unsigned)
<LI><a href="#[1019858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECheckButton::ECheckButton(bool, EPosition, char*, unsigned)
</UL>

<P><STRONG><a name="[ff06f8]"></a>ESize::ESize__sub_object(unsigned, unsigned)</STRONG> (ARM, 0 bytes, Stack size 0 bytes, econtrol.o(i._ZN5ESizeC1Ejj), UNUSED)

<P><STRONG><a name="[ff06b0]"></a>ETree::ETreeSubItem::OpenSubItem()</STRONG> (ARM, 36 bytes, Stack size 8 bytes, econtrol.o(i._ZN5ETree12ETreeSubItem11OpenSubItemEv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100dab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::OpenAllSubItem()
</UL>
<BR>[Called By]<UL><LI><a href="#[100d990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultETree(EControl*, EEvent*)
<LI><a href="#[100dab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::OpenAllSubItem()
</UL>

<P><STRONG><a name="[ff0668]"></a>ETree::ETreeSubItem::CloseSubItem()</STRONG> (ARM, 36 bytes, Stack size 8 bytes, econtrol.o(i._ZN5ETree12ETreeSubItem12CloseSubItemEv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100da68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::CloseAllSubItem()
</UL>
<BR>[Called By]<UL><LI><a href="#[100d990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultETree(EControl*, EEvent*)
<LI><a href="#[100da68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ETreeItem::CloseAllSubItem()
</UL>

<P><STRONG><a name="[feac18]"></a>EEvent::EEvent()</STRONG> (ARM, 52 bytes, Stack size 8 bytes, eframe.o(i._ZN6EEventC1Ev), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[feb0e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetCursorEvent(const EPosition&, unsigned)
<LI><a href="#[feb170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetKeyboardEvent(const EPosition&, unsigned)
</UL>

<P><STRONG><a name="[feabd0]"></a>EEvent::EEvent__sub_object()</STRONG> (ARM, 0 bytes, Stack size 8 bytes, eframe.o(i._ZN6EEventC1Ev), UNUSED)

<P><STRONG><a name="[1019b28]"></a>ELabel::~ELabel()</STRONG> (ARM, 8 bytes, Stack size 0 bytes, guidemo.o(i._ZN6ELabelD1Ev))
<BR>[Address Reference Count : 1]<UL><LI> guidemo.o(.text)
</UL>
<P><STRONG><a name="[1019ae0]"></a>ELabel::~ELabel__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, guidemo.o(i._ZN6ELabelD1Ev), UNUSED)

<P><STRONG><a name="[1019a98]"></a>EButton::~EButton()</STRONG> (ARM, 8 bytes, Stack size 0 bytes, guidemo.o(i._ZN7EButtonD1Ev))
<BR>[Address Reference Count : 1]<UL><LI> guidemo.o(.text)
</UL>
<P><STRONG><a name="[1019a50]"></a>EButton::~EButton__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, guidemo.o(i._ZN7EButtonD1Ev), UNUSED)

<P><STRONG><a name="[feab88]"></a>EWindow::GetWindowState()</STRONG> (ARM, 12 bytes, Stack size 0 bytes, eframe.o(i._ZN7EWindow14GetWindowStateEv))
<BR>[Address Reference Count : 1]<UL><LI> eframe.o(.constdata__ZTV7EWindow)
</UL>
<P><STRONG><a name="[1019a08]"></a>EWindow::~EWindow()</STRONG> (ARM, 16 bytes, Stack size 0 bytes, guidemo.o(i._ZN7EWindowD1Ev))
<BR>[Address Reference Count : 1]<UL><LI> guidemo.o(.text)
</UL>
<P><STRONG><a name="[10199c0]"></a>EWindow::~EWindow__sub_object()</STRONG> (ARM, 0 bytes, Stack size 0 bytes, guidemo.o(i._ZN7EWindowD1Ev), UNUSED)

<P><STRONG><a name="[ff0620]"></a>EControl::RedrawControl()</STRONG> (ARM, 44 bytes, Stack size 8 bytes, econtrol.o(i._ZN8EControl13RedrawControlEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[feae10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::RedrawDesktop()
<LI><a href="#[feb908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::RedrawSelectedControls()
<LI><a href="#[feb950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::ForceRedrawAllControls()
<LI><a href="#[febb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::RedrawControl(const EPosition&)
<LI><a href="#[febbd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::RedrawSelectedControls()
<LI><a href="#[febc20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleWindow::ForceRedrawAllControls()
<LI><a href="#[ff0428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::SetSelectIndex(unsigned)
<LI><a href="#[100be48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ToggleLeafState(unsigned, unsigned)
<LI><a href="#[100be90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ETree::ToggleRootState(unsigned)
<LI><a href="#[100c1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::ShowPopupMenu(const EPosition&)
<LI><a href="#[100caa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMessageBox::SwitchState()
<LI><a href="#[100ce08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::RemoveItem(unsigned)
<LI><a href="#[100ce50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::AddItem(char*)
<LI><a href="#[100ce98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::SetIemString(unsigned, char*)
<LI><a href="#[100d1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::SetString(char*, int)
<LI><a href="#[100d318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::SetString(char*)
<LI><a href="#[100d630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEBarChart(EControl*, EEvent*)
<LI><a href="#[100d708]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEToolBar(EControl*)
<LI><a href="#[100d798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEToolBar(EControl*, EEvent*)
<LI><a href="#[100d828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::NoticeControl(EEvent*)
<LI><a href="#[100d990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultETree(EControl*, EEvent*)
<LI><a href="#[100db40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEPopupMenu(EControl*, EEvent*)
<LI><a href="#[100dbd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEMenu(EControl*, EEvent*)
<LI><a href="#[100dc18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::SwitchShowState()
<LI><a href="#[100dcf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEList(EControl*, EEvent*)
<LI><a href="#[100dd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEScroll(EControl*, EEvent*)
<LI><a href="#[100de10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEDialogBox(EControl*, EEvent*)
<LI><a href="#[100dee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEMessageBox(EControl*, EEvent*)
<LI><a href="#[100e050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*)
<LI><a href="#[100e098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::SwitchOpenState()
<LI><a href="#[100e128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEExtLabel(EControl*, EEvent*)
<LI><a href="#[100e170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EExtLabel::ChangeState()
<LI><a href="#[100e248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEEdit(EControl*, EEvent*)
<LI><a href="#[100e2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultECheckButton(EControl*, EEvent*)
<LI><a href="#[10196a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::AddCharToString(char)
</UL>

<P><STRONG><a name="[ff05d8]"></a>EControl::SetRedrawFunction(void(*)(EControl*))</STRONG> (ARM, 8 bytes, Stack size 0 bytes, econtrol.o(i._ZN8EControl17SetRedrawFunctionEPFvPS_E), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[100cbc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIconButton::EIconButton(void(*)(EControl*, EEvent*), EPosition, ESize, unsigned, char*, bool)
<LI><a href="#[100cca0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIconButton::EIconButton(void(*)(EControl*, EEvent*), EPosition, ESize, ESize, unsigned char*, char*, bool)
</UL>

<P><STRONG><a name="[ff0590]"></a>EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))</STRONG> (ARM, 84 bytes, Stack size 16 bytes, econtrol.o(i._ZN8EControlC1EPFvPS_P6EEventEPFvS0_E), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff0740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESize::ESize(unsigned, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[100bc98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::EToolBar()
<LI><a href="#[100c3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPopupMenu::EPopupMenu()
<LI><a href="#[100c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EScroll::EScroll()
<LI><a href="#[100cfb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::EComboBox()
</UL>

<P><STRONG><a name="[ff0548]"></a>EControl::EControl__sub_object(void(*)(EControl*, EEvent*), void(*)(EControl*))</STRONG> (ARM, 0 bytes, Stack size 16 bytes, econtrol.o(i._ZN8EControlC1EPFvPS_P6EEventEPFvS0_E), UNUSED)

<P><STRONG><a name="[ff0500]"></a>EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)</STRONG> (ARM, 60 bytes, Stack size 16 bytes, econtrol.o(i._ZN8EControlC1EPFvPS_P6EEventEPFvS0_E5ESize9EPosition))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)
</UL>
<BR>[Called By]<UL><LI><a href="#[100bc08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EToolBar::EToolBar(EPosition)
<LI><a href="#[100c5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::EMenu(char*, unsigned, EPosition, bool)
<LI><a href="#[100c940]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EScroll::EScroll(EPosition, unsigned, unsigned)
<LI><a href="#[100ca60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDialogBox::EDialogBox(unsigned char, EPosition, char*, unsigned)
<LI><a href="#[100cb38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMessageBox::EMessageBox(unsigned char, EPosition, char*, unsigned)
<LI><a href="#[100cca0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIconButton::EIconButton(void(*)(EControl*, EEvent*), EPosition, ESize, ESize, unsigned char*, char*, bool)
<LI><a href="#[100cd78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EIcon::EIcon(void(*)(EControl*, EEvent*), EPosition, unsigned)
<LI><a href="#[100cf28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EComboBox::EComboBox(EPosition, unsigned)
<LI><a href="#[100d240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(void(*)(EControl*, EEvent*), char*, bool, EPosition, unsigned)
<LI><a href="#[100d2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(char*, bool, EPosition, unsigned)
<LI><a href="#[100d3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECheckButton::ECheckButton(void(*)(EControl*, EEvent*), bool, EPosition, char*, unsigned)
<LI><a href="#[100d510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(void(*)(EControl*, EEvent*), void(*)(EControl*), EPosition, char*, unsigned)
<LI><a href="#[10195d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EButton::EButton(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)
<LI><a href="#[1019618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(EPosition, char*, unsigned)
<LI><a href="#[1019660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(bool, EPosition, unsigned)
<LI><a href="#[1019858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECheckButton::ECheckButton(bool, EPosition, char*, unsigned)
</UL>

<P><STRONG><a name="[ff04b8]"></a>EControl::EControl__sub_object(void(*)(EControl*, EEvent*), void(*)(EControl*), ESize, EPosition)</STRONG> (ARM, 0 bytes, Stack size 16 bytes, econtrol.o(i._ZN8EControlC1EPFvPS_P6EEventEPFvS0_E5ESize9EPosition), UNUSED)

<P><STRONG><a name="[ff0470]"></a>EComboBox::GetItemString(unsigned)</STRONG> (ARM, 24 bytes, Stack size 0 bytes, econtrol.o(i._ZN9EComboBox13GetItemStringEj))
<BR><BR>[Called By]<UL><LI><a href="#[100e008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEComboBox(EControl*)
</UL>

<P><STRONG><a name="[ff0428]"></a>EComboBox::SetSelectIndex(unsigned)</STRONG> (ARM, 32 bytes, Stack size 16 bytes, econtrol.o(i._ZN9EComboBox14SetSelectIndexEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EComboBox::SetSelectIndex(unsigned) &rArr; EControl::RedrawControl()
</UL>
<BR>[Calls]<UL><LI><a href="#[ff0620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::RedrawControl()
</UL>
<BR>[Called By]<UL><LI><a href="#[100e050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_CallbackFunc_DefaultEComboBox(EControl*, EEvent*)
</UL>

<P><STRONG><a name="[1019978]"></a>EPosition::EPosition(unsigned, unsigned)</STRONG> (ARM, 12 bytes, Stack size 0 bytes, guidemo.o(i._ZN9EPositionC1Ejj))
<BR><BR>[Called By]<UL><LI><a href="#[feac18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEvent::EEvent()
<LI><a href="#[feaee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EDesktop::AppendStartMenu(EMenu*)
<LI><a href="#[feb0e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::SetCursorEvent(const EPosition&, unsigned)
<LI><a href="#[feba70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow()
<LI><a href="#[ff0590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EControl::EControl(void(*)(EControl*, EEvent*), void(*)(EControl*))
<LI><a href="#[100c670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMenu::EMenu()
<LI><a href="#[100d168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EExtLabel::EExtLabel()
<LI><a href="#[100d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultETree(EControl*)
<LI><a href="#[100e1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEProgress(EControl*)
<LI><a href="#[100e200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultEEdit(EControl*)
<LI><a href="#[100e290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EG_RedrawFunc_DefaultECheckButton(EControl*)
<LI><a href="#[1019588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow(char*, EPosition, ESize, bool)
<LI><a href="#[10196f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::ESimpleDesktop()
<LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp
</UL>

<P><STRONG><a name="[1019930]"></a>EPosition::EPosition__sub_object(unsigned, unsigned)</STRONG> (ARM, 0 bytes, Stack size 0 bytes, guidemo.o(i._ZN9EPositionC1Ejj), UNUSED)

<P><STRONG><a name="[fe4bf8]"></a>__aeabi_atexit</STRONG> (Thumb, 48 bytes, Stack size 32 bytes, aeabi_atexit.o(i.__aeabi_atexit))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = __aeabi_atexit &rArr; malloc &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11f0020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
<LI><a href="#[11f04a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ddtor_pointer_addr (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[101aed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___11_GUIdemo_cpp (via Veneer)
</UL>

<P><STRONG><a name="[11ed418]"></a>__cxa_finalize</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, cxa_finalize.o(i.__cxa_finalize))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = __cxa_finalize &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[11eb140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
<LI><a href="#[11eccf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[11f04a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ddtor_pointer_addr (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11e9d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown
</UL>

<P><STRONG><a name="[11e7928]"></a>_fp_init</STRONG> (ARM, 24 bytes, Stack size 8 bytes, fpinit.o(x$fpl$fpinit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _fp_init
</UL>
<BR>[Calls]<UL><LI><a href="#[11e71d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_fp_status_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[11e78e0]"></a>__fplib_config_pureend_doubles</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)
<P>
<H3>
Local Symbols
</H3>
<P><STRONG><a name="[bc35b0]"></a>Undef_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, startup.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[bc35b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[bc35b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[bc3568]"></a>PAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, startup.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[bc3568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[bc3568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[bc3520]"></a>DAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, startup.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[bc3520]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[bc3520]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[bc34d8]"></a>IRQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, startup.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[bc34d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[bc34d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[bc3490]"></a>FIQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, startup.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[bc3490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[bc3490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup.o(RESET)
</UL>
<P><STRONG><a name="[bc0b00]"></a>prvSetupHardware</STRONG> (ARM, 64 bytes, Stack size 0 bytes, main.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bbfea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[bb9148]"></a>prvUnlockQueue</STRONG> (ARM, 192 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = prvUnlockQueue &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[bb84a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[bb85c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskMissedYield
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb9100]"></a>prvIsQueueFull</STRONG> (ARM, 60 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvIsQueueFull
</UL>
<BR>[Calls]<UL><LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[bb90b8]"></a>prvCopyDataToQueue</STRONG> (ARM, 180 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[fe6b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe0c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[bb9070]"></a>prvIsQueueEmpty</STRONG> (ARM, 56 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvIsQueueEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb9028]"></a>prvCopyDataFromQueue</STRONG> (ARM, 88 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvCopyDataFromQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[fe6b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[bbe080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceiveFromISR
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[bb7190]"></a>prvInitialiseTaskLists</STRONG> (ARM, 112 bytes, Stack size 8 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = prvInitialiseTaskLists
</UL>
<BR>[Calls]<UL><LI><a href="#[bbc5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialise
</UL>
<BR>[Called By]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
</UL>

<P><STRONG><a name="[bb7148]"></a>prvInitialiseTCBVariables</STRONG> (ARM, 104 bytes, Stack size 24 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = prvInitialiseTCBVariables &rArr; strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[bbc560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialiseItem
<LI><a href="#[fe6890]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>
<BR>[Called By]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
</UL>

<P><STRONG><a name="[bb7100]"></a>prvAllocateTCBAndStack</STRONG> (ARM, 100 bytes, Stack size 16 bytes, tasks.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = prvAllocateTCBAndStack &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; vTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[bbb070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[bbc5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
<LI><a href="#[fe6cd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[bb6728]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGenericCreate
</UL>

<P><STRONG><a name="[bb70b8]"></a>prvDeleteTCB</STRONG> (ARM, 32 bytes, Stack size 8 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbb070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
</UL>
<BR>[Called By]<UL><LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
</UL>

<P><STRONG><a name="[bb7070]"></a>prvCheckTasksWaitingTermination</STRONG> (ARM, 184 bytes, Stack size 16 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb70b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvDeleteTCB
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbc488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListRemove
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[bb7028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
</UL>

<P><STRONG><a name="[bb7028]"></a>prvIdleTask</STRONG> (ARM, 36 bytes, Stack size 8 bytes, tasks.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb7070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
</UL>

<P><STRONG><a name="[bb5288]"></a>prvSetupTimerInterrupt</STRONG> (ARM, 100 bytes, Stack size 0 bytes, port.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bb6260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
</UL>

<P><STRONG><a name="[101aed8]"></a>__sti___11_GUIdemo_cpp</STRONG> (ARM, 708 bytes, Stack size 88 bytes, guidemo.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = __sti___11_GUIdemo_cpp &rArr; __aeabi_atexit &rArr; malloc &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; free
</UL>
<BR>[Calls]<UL><LI><a href="#[fe4bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit (via Veneer)
<LI><a href="#[1019588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EWindow::EWindow(char*, EPosition, ESize, bool)
<LI><a href="#[10195d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EButton::EButton(void(*)(EControl*, EEvent*), EPosition, char*, unsigned)
<LI><a href="#[1019618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ELabel::ELabel(EPosition, char*, unsigned)
<LI><a href="#[1019660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EEdit::EEdit(bool, EPosition, unsigned)
<LI><a href="#[10196f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ESimpleDesktop::ESimpleDesktop()
<LI><a href="#[1019858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ECheckButton::ECheckButton(bool, EPosition, char*, unsigned)
<LI><a href="#[1019978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EPosition::EPosition(unsigned, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> guidemo.o(.init_array)
</UL>
<P><STRONG><a name="[1017b08]"></a>vQueueReceiveWhenSuspendedTask</STRONG> (ARM, 144 bytes, Stack size 8 bytes, dynamic.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[1017ac0]"></a>vQueueSendWhenSuspendedTask</STRONG> (ARM, 92 bytes, Stack size 8 bytes, dynamic.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[1017a78]"></a>vCounterControlTask</STRONG> (ARM, 232 bytes, Stack size 16 bytes, dynamic.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb64a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskResume
<LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bbaf50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[bbaf98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>

<P><STRONG><a name="[1017a30]"></a>vLimitedIncrementTask</STRONG> (ARM, 60 bytes, Stack size 16 bytes, dynamic.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
</UL>

<P><STRONG><a name="[10179e8]"></a>vContinuousIncrementTask</STRONG> (ARM, 68 bytes, Stack size 16 bytes, dynamic.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPrioritySet
<LI><a href="#[bb65c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxTaskPriorityGet
</UL>

<P><STRONG><a name="[1016458]"></a>vLEDFlashTask</STRONG> (ARM, 116 bytes, Stack size 16 bytes, flash.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelayUntil
<LI><a href="#[bbc440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetTickCount
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[bc1f78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vParTestToggleLED
</UL>

<P><STRONG><a name="[1014ef0]"></a>vPolledQueueProducer</STRONG> (ARM, 144 bytes, Stack size 24 bytes, pollq.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>

<P><STRONG><a name="[1014ea8]"></a>vPolledQueueConsumer</STRONG> (ARM, 148 bytes, Stack size 24 bytes, pollq.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb87b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxQueueMessagesWaiting
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>

<P><STRONG><a name="[10138e0]"></a>vBlockingQueueConsumer</STRONG> (ARM, 120 bytes, Stack size 24 bytes, blockq.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
</UL>

<P><STRONG><a name="[1013898]"></a>vBlockingQueueProducer</STRONG> (ARM, 116 bytes, Stack size 24 bytes, blockq.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[1010aa8]"></a>prvSemaphoreTest</STRONG> (ARM, 296 bytes, Stack size 32 bytes, semtest.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bb6608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskDelay
<LI><a href="#[bb8608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortYield
<LI><a href="#[bbe110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[bbe158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReceive
<LI><a href="#[bbe278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[bbe2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>

<P><STRONG><a name="[fe65c8]"></a>__arm_div8</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[fe6580]"></a>__arm_div4</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[fe6538]"></a>__arm_div_large</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fe6418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>
<P>
<H3>
Undefined Global Symbols
</H3>
<P><STRONG><a name="[11e9c78]"></a>__ARM_exceptions_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9c30]"></a>__alloca_initialize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[fe5648]"></a>__user_heap_extend</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[fe5720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[11e9be8]"></a>_atexit_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11ea438]"></a>_call_atexit_fns</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11ea4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
</UL>

<P><STRONG><a name="[11e9ba0]"></a>_clock_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9b58]"></a>_fp_trap_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9b10]"></a>_get_lc_collate</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9ac8]"></a>_get_lc_ctype</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9a80]"></a>_get_lc_monetary</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9a38]"></a>_get_lc_numeric</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e99f0]"></a>_get_lc_time</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e99a8]"></a>_getenv_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9918]"></a>_initio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e98d0]"></a>_rand_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e9888]"></a>_signal_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11e97f8]"></a>_terminateio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11e9d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>
<HR></body></html>
